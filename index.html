<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>풍무고등학교 수시 입시 결과 통계프로그램</title>

  <!-- 외부 라이브러리 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>


  <style>
    :root {
      --bg: #f6f4ef;
      --card: #ffffff;
      --border: #d9d2c3;
      --primary: #6b8f71;
      --primary-dark: #58765e;
      --accent: #d07a5c;
      --text: #2f3c32;
      --muted: #6a7065;
      --shadow: 0 10px 28px rgba(47,60,50,0.12);
      --stickyTop: 190px;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: "Noto Sans KR", "Pretendard", system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
    }

    /* ✅ 추가: 표/빈데이터 기본 스타일 */
    .stats-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }
    .stats-table th, .stats-table td {
      border: 1px solid #e4ddcf;
      padding: 7px;
      text-align: center;
    }
    .stats-table thead th {
      background: #f1ede5;
      font-weight: 800;
    }
    .empty {
      padding: 18px;
      border: 1px dashed #d9d2c3;
      border-radius: 12px;
      color: var(--muted);
      text-align: center;
      background: #fff;
    }

    /* ===== 상단 ===== */
    .hero {
      padding: 28px 20px 14px;
      text-align: center;
    }

    .panel {
      max-width: 1160px;
      margin: 0 auto 18px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 18px;
      box-shadow: var(--shadow);
    }

    .actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    button {
      cursor: pointer;
      border: 1px solid var(--border);
      background: #eef0eb;
      padding: 10px 14px;
      border-radius: 10px;
      font-weight: 600;
    }

    button.primary {
      background: var(--primary);
      color: #fff;
    }

    /* ===== 고정 헤더 ===== */
    .fixed-header {
      position: sticky;
      top: 0;
      z-index: 50;
      background: rgba(255,255,255,0.95);
      border-bottom: 1px solid var(--border);
      box-shadow: 0 6px 18px rgba(0,0,0,0.08);
    }

    .header-content {
      max-width: 1200px;
      margin: 0 auto;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .grade-toggle-btn.active {
      background: var(--accent);
      color: #fff;
    }

    /* ===== 레이아웃 ===== */
    .layout {
      max-width: 1200px;
      margin: 0 auto 32px;
      display: flex;
      gap: 16px;
      padding: 0 12px;
      align-items: flex-start;
    }

    .toc-container {
      flex: 0 0 220px;
      position: sticky;
      top: var(--stickyTop);
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 14px;
      box-shadow: var(--shadow);
      max-height: calc(100vh - 200px);
      overflow-y: auto;
    }

    .main-content {
      flex: 1;
      padding: 0;
    }

    .dept-container {
      margin-bottom: 28px;
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 20px;
      background: #fff;
      box-shadow: var(--shadow);
    }

    .dept-header {
      font-size: 20px;
      font-weight: 800;
      margin-bottom: 14px;
      border-bottom: 2px solid var(--primary);
      padding-bottom: 8px;
    }

    .print-grade-line {
      font-weight: 800;
      margin-bottom: 6px;
    }

    /* ===== 인쇄 ===== */
    @media print {
      @page { size: A4 portrait; margin: 12mm; }

      body { background: #fff !important; }

      .hero, .panel, .fixed-header, .toc-container {
        display: none !important;
      }

      .layout {
        display: block !important;
        padding: 0 !important;
      }

      .dept-container {
        page-break-before: always;
        break-before: page;
        box-shadow: none;
        border: none;
      }
body.print-overall #report .dept-container:not(#overall-summary) { display:none !important; }
body.print-capital #report .dept-container:not(#capital-summary) { display:none !important; }
body.print-special #report .dept-container:not(#special-summary) { display:none !important; }

      body.print-overall #overall-summary,
body.print-capital #capital-summary,
body.print-special #special-summary {
  page-break-before: auto !important;
  break-before: auto !important;
}

      /* ✅ 첫 블록은 강제 페이지 브레이크 제거 */
      #overall-summary {
        page-break-before: auto !important;
        break-before: auto !important;
      }

      .plot-container {
        height: 320px !important;
      }
    }
    /* ✅ 파일선택(input) + 버튼(actions) 한 줄 고정 */
.panel .field{
  display: flex;
  align-items: center;
  gap: 12px;
  flex-wrap: nowrap;      /* 데스크톱에서 2줄 방지 */
}

/* ✅ file input이 버튼을 밀어내지 않게 폭 제한 */
.panel .field #file-input{
  flex: 1 1 auto;         /* 남는 공간은 먹되 */
  min-width: 260px;
  max-width: 520px;       /* 너무 커져서 버튼을 아래로 밀지 않게 */
}

/* ✅ 버튼들도 한 줄 고정 */
.panel .field .actions{
  display: flex;
  gap: 10px;
  flex-wrap: nowrap;      /* 버튼 2개가 줄바꿈 안 되게 */
  flex: 0 0 auto;
}

/* ✅ 화면이 좁을 때만 줄바꿈 허용(모바일/작은 창 대응) */
@media (max-width: 560px){
  .panel .field{ flex-wrap: wrap; }
  .panel .field #file-input{ max-width: 100%; }
  .panel .field .actions{ width: 100%; }
}
/* ✅ 고정헤더 아래 콘텐츠가 너무 달라붙지 않게 */
.layout{
  margin-top: 14px;
}
/* ✅ 고정헤더 '흰 띠' 느낌 줄이고, 내용만 카드처럼 보이게 */
.fixed-header{
  background: transparent;      /* 전체 폭 흰 배경 제거 */
  border-bottom: none;
  box-shadow: none;
  padding: 10px 0;
}

.header-content{
  background: rgba(255,255,255,0.96);
  border: 1px solid var(--border);
  border-radius: 14px;
  box-shadow: var(--shadow);
}
/* =========================
   ✅ 고정헤더 유지 + 아래 콘텐츠 '달라붙음' 해결 패치
   (style 맨 아래에 붙여넣기)
   ========================= */

/* 1) 고정헤더가 화면 전체를 '흰 띠'로 덮는 느낌 줄이기
      -> 바깥은 투명, 안쪽만 카드 */
.fixed-header{
  background: transparent;
  border-bottom: none;
  box-shadow: none;
  padding: 10px 0;
}

/* 고정헤더 내부를 카드처럼 */
.header-content{
  background: rgba(255,255,255,0.96);
  border: 1px solid var(--border);
  border-radius: 14px;
  box-shadow: var(--shadow);
}

/* 2) 고정헤더 아래 첫 콘텐츠(목차/출력기준)가 달라붙지 않도록 간격 확보 */
.layout{
  margin-top: 14px;
}

/* 3) 고정헤더가 살짝 떠보이게(상단 여백) + 스크롤 시 시각적 분리 */
.fixed-header::after{
  content:"";
  display:block;
  height: 8px;
}
/* =========================
   ✅ 고정헤더 내부(제목/토글/범례) 정돈
   ========================= */

/* modified by KO: 작게/연하게/정렬 */
.site-title{
  font-size: 12px;
  color: var(--muted);
  font-weight: 600;
  letter-spacing: 0.2px;
}

/* 헤더 내부 타이틀 간격 */
.university-title{
  margin: 4px 0 2px;
  font-size: 20px;
  font-weight: 900;
}

/* 토글/범례 래퍼: 줄바꿈해도 간격 유지 */
.controls-legend-wrapper{
  gap: 10px !important;
}

/* 토글 버튼: 폭/간격 통일 */
.grade-toggle-container{
  display: inline-flex;
  gap: 8px;
  align-items: center;
}
.grade-toggle-btn{
  min-width: 120px;
}

/* 범례 박스: 안쪽 간격 + 줄바꿈 시 보기 좋게 */
.legend-container{
  line-height: 1.35;
}
.legend-items-wrapper{
  row-gap: 6px !important;
}

/* (선택) 작은 화면에서 토글/범례가 너무 타이트하면 자동 줄바꿈 */
@media (max-width: 900px){
  .grade-toggle-btn{ min-width: 110px; }
}
/* =========================
   ✅ 목차/출력기준 '달라붙음' 개선
   ========================= */

/* 고정헤더 밑 시작 여백 */
.layout{
  margin-top: 18px;
}

/* 목차 박스 자체도 살짝 아래로 여유 */
.toc-container{
  padding-top: 16px;
}

/* 본문 첫 번째 요약 박스(출력 기준)가 위에 너무 붙지 않게 */
#content-area > .dept-container:first-child{
  margin-top: 10px;
}
/* ===== 출력 모드 분기 ===== */
/* 기본(전체 출력): 제한 없음 */

@media print {
  /* 전체 출력은 그대로 */

  /* 현황 1부: overall-summary만 출력 */
  body.print-overall #report .dept-container:not(#overall-summary) {
    display: none !important;
  }

  /* 서울+수도권 출력: capital-summary만 출력 */
  body.print-capital #report .dept-container:not(#capital-summary) {
    display: none !important;
  }

  /* 특정 섹션은 페이지 브레이크 최소화 */
  body.print-overall #overall-summary,
  body.print-capital #capital-summary {
    page-break-before: auto !important;
    break-before: auto !important;
  }
}

    
  </style>
</head>

<body>
  <header class="hero">
    <h1>수시 입시 결과 통계 프로그램 [풍무고등학교]</h1>
    <p>대교협상담프로그램 - 진학관리 - 수시진학관리의 엑셀파일을 업로드 하면 됩니다.</p>
  </header>

 <section class="panel">
  <h2>엑셀 업로드</h2>
  <div class="field">
    <input type="file" id="file-input" accept=".xlsx,.xls" />
    <div class="actions">
      <button class="primary" id="generate-btn">보고서 생성</button>

      <!-- 출력 모드 3종 -->
      <button id="print-overall-btn">현황 1부 출력</button>
      <button id="print-capital-btn">서울+수도권 출력</button>
      <button id="print-full-btn">전체 출력(PDF)</button>

      <!-- 보고서 HTML 저장 -->
      <button id="save-html-btn">보고서 HTML 저장</button>
    </div>
  </div>
  <div id="status"></div>
</section>


  <section id="report" hidden></section>

  <script>
    const RESULT_ORDER = ["합격", "충원합격", "불합격"];
    const COLOR_MAP = {
      "합격":   { border: "#5f8669", fill: "rgba(95, 134, 105, 0.30)" },
      "충원합격": { border: "#7cab7c", fill: "rgba(124, 171, 124, 0.28)" },
      "불합격": { border: "#d07a5c", fill: "rgba(208, 122, 92, 0.32)" },
    };
    const SYMBOL_MAP = { "합격": "circle", "충원합격": "triangle-up", "불합격": "x" };
    const Y_POS = { "합격": 0.01, "충원합격": 0.0, "불합격": -0.03 };
    const BINS = { start: 1, end: 9, size: 0.5 };

    const fileInput = document.getElementById("file-input");
    const statusEl  = document.getElementById("status");
    const reportEl  = document.getElementById("report");
    const generateBtn = document.getElementById("generate-btn");

    let currentGradeType = "all_subj";
    let plotsData = {};
    let plotInitialized = {};
    let lastRecords = null;

    generateBtn.addEventListener("click", handleGenerate);

    // ✅ 인쇄 버튼(3종) 이벤트
document.getElementById("print-overall-btn").addEventListener("click", () => printWithMode("overall"));
document.getElementById("print-capital-btn").addEventListener("click", () => printWithMode("capital"));
document.getElementById("print-full-btn").addEventListener("click", () => printWithMode("full"));

    function setStatus(msg, isError = false) {
      statusEl.textContent = msg;
      statusEl.style.color = isError ? "#c0392b" : "#607089";
    }

    async function handleGenerate() {
      const file = fileInput.files[0];
      if (!file) {
        setStatus("엑셀 파일을 선택해주세요.", true);
        return;
      }
      setStatus("엑셀을 읽는 중...");

      try {
        const records = await parseExcel(file);
        if (!records.length) {
          setStatus("유효한 데이터가 없습니다. 필수 컬럼을 확인하세요.", true);
          return;
        }
        lastRecords = records;
        renderFullReport(records);
        setStatus(`총 ${records.length}건 로드 완료. 보고서가 생성되었습니다.`);
      } catch (e) {
        console.error(e);
        setStatus("처리 중 오류: " + e.message, true);
      }
    }

    function parseExcel(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();

        reader.onload = (e) => {
          try {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: "array" });
            const sheet = workbook.Sheets[workbook.SheetNames[0]];

            // 첫 2행 스킵(사용자 원본 로직 유지)
            const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, range: 2 });

            // 형식 판별(사용자 원본 로직 유지)
            const isAltFormat = (() => {
              const cell = sheet["V1"];
              const val = cell ? String(cell.v || "").trim() : "";
              return val.includes("최종단계");
            })();

            // 기본: result=R(17), all_subj=AG(32), conv=AH(33)
            // 대안: result=V(21), all_subj=R(17), conv=T(19)
            const COL = {
              region: 5,  // F
              univ: 6,    // G
              apptype: 8, // I
              subtype: 10,// K
              dept: 12,   // M
              result: isAltFormat ? 21 : 17,
              all:    isAltFormat ? 17 : 32,
              conv:   isAltFormat ? 19 : 33,
            };

            const records = [];
            rows.forEach((row) => {
              const rec = {
                grade: safe(row[0]),          // A: 학년
                class_no: safe(row[1]),       // B: 반
                student_no: safe(row[2]),     // C: 번호
                student_name: safe(row[3]),   // D: 이름
                region: safe(row[COL.region]),
                univ: safe(row[COL.univ]),
                apptype: safe(row[COL.apptype]),
                subtype: safe(row[COL.subtype]),
                dept: safe(row[COL.dept]),
                result: safe(row[COL.result]),
                all_subj_grade: parseGrade(row[COL.all]),
                conv_grade: parseGrade(row[COL.conv]),
              };

              // 필수값 체크
              if (!rec.result || !rec.univ || !rec.dept || !rec.subtype || !rec.apptype) return;
              if (rec.all_subj_grade === null && rec.conv_grade === null) return;

              records.push(rec);
            });

            resolve(records);
          } catch (err) {
            reject(err);
          }
        };

        reader.onerror = (err) => reject(err);
        reader.readAsArrayBuffer(file);
      });
    }

    function safe(v) {
      return v === undefined || v === null ? "" : String(v).trim();
    }

    function parseGrade(v) {
      const n = parseFloat(v);
      return Number.isFinite(n) ? n : null;
    }

    function unique(arr) {
      return Array.from(new Set(arr)).filter(Boolean).sort();
    }

// (A) 버튼 이벤트는 전부 여기
document.getElementById("save-html-btn").addEventListener("click", saveHtmlReport);

function saveHtmlReport() {
  if (reportEl.hidden) {
    alert("먼저 보고서를 생성해주세요.");
    return;
  }
function printWithMode(mode) {
  if (reportEl.hidden) {
    alert("먼저 보고서를 생성해주세요!");
    return;
  }

  // 모드 초기화
  document.body.classList.remove("print-overall", "print-capital", "print-special");

  if (mode === "overall") document.body.classList.add("print-overall");
  if (mode === "capital") document.body.classList.add("print-capital");
  if (mode === "special") document.body.classList.add("print-special");
  // mode === "full"이면 아무 클래스도 안 붙인 상태 = 전체 출력

  window.print();

  // 출력 후 원복
  document.body.classList.remove("print-overall", "print-capital", "print-special");
}


  const html = `
<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>수시 입시 결과 보고서</title>
${document.querySelector("style").outerHTML}
<script src="https://cdn.plot.ly/plotly-2.32.0.min.js"><\/script>
</head>
<body>
${reportEl.innerHTML}
</body>
</html>
  `.trim();

  const blob = new Blob([html], { type: "text/html;charset=utf-8;" });
  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;
  a.download = "수시_입시결과_보고서.html";
  a.click();

  URL.revokeObjectURL(url);
}
  



// ===== (A) 대학명 정규화 / 캠퍼스 판정 / 지역 보정 =====

// 1) 상위권(일반) 대학 고정 리스트 (필요시 계속 추가)
const TOP_TIER_UNIVS = [
  "서울대","연세대","고려대","서강대","성균관대","한양대",
  "중앙대","경희대","한국외대","이화여대",
  "건국대","동국대","홍익대","숙명여대"
];

// 2) 특수목적대학(특목대) 고정 리스트(필요시 추가/수정)
const SPECIAL_PURPOSE_UNIVS = [
  // 이공계 특성화
  "KAIST","GIST","DGIST","UNIST","KENTEC",
  // 사관/특수
  "육사","해사","공사","국간사","경찰대"
];

// 3) 문자열 정규화(공백/대학/대학교 등 흔한 흔들림 완화)
    function normalizeUnivName(raw) {
  if (!raw) return "";
  let s = String(raw).trim();

  s = s.replace(/\s*\(\s*/g, "(").replace(/\s*\)\s*/g, ")");
  s = s.replace(/대학교/g, "").replace(/대학$/g, "");

  // ✅ 특목대 표기 통일(한글/정식명/별칭 → 약칭)
  s = s.replace(/(한국과학기술원|카이스트)/g, "KAIST");
  s = s.replace(/(울산과학기술원|유니스트)/g, "UNIST");
  s = s.replace(/(대구경북과학기술원|디지스트)/g, "DGIST");
  s = s.replace(/(광주과학기술원|지스트)/g, "GIST");
  s = s.replace(/(한국에너지공과대|한국에너지공과대학교|켄텍|KENTECH)/g, "KENTEC");

  return s;
}

// 4) "고려대(세종)" 같은 캠퍼스 태그 추출
function getCampusTag(univName) {
  const m = univName.match(/\(([^)]+)\)/);
  return m ? m[1].trim() : ""; // 예: "세종", "안암", "ERICA", "미래", "글로컬"
}

// 5) 대학명 기반 수도권 판정(지역값이 비어 있거나, 캠퍼스 예외가 필요한 경우)
function inferCapitalByUniv(univRaw) {
  const u = normalizeUnivName(univRaw);
  const campus = getCampusTag(u);

  // ----- 캠퍼스 예외(중요) -----
  // 고려대(세종) = 비수도권(세종)
  if (u.includes("고려대") && campus.includes("세종")) return false;

  // 연세대(미래) = 원주(강원) -> 비수도권
  if (u.includes("연세대") && campus.includes("미래")) return false;

  // 건국대(글로컬) = 충주 -> 비수도권
  if (u.includes("건국대") && campus.includes("글로컬")) return false;

  // ----- 수도권으로 보는 케이스(캠퍼스 표기가 있어도 수도권일 수 있음) -----
  // 한양대(ERICA) = 경기(안산) -> 수도권
  if (u.includes("한양대") && campus.toUpperCase().includes("ERICA")) return true;

  // ----- 기본 대학명 매칭(수도권으로 볼 대학들) -----
  // 여기서 “서울권/수도권 대학”을 넓게 잡을지, 좁게 잡을지 네 기준대로 확장 가능
  const capitalByName = [
    "서울대","연세대","고려대","서강대","성균관대","한양대",
    "중앙대","경희대","한국외대","이화여대","건국대","동국대",
    "홍익대","숙명여대",
    // 수도권 주요 대학 예시(원하면 추가)
    "인하대","아주대","가천대","단국대","국민대","숭실대","세종대","광운대","서울시립대"
  ];

  // "XX대(캠퍼스)"에서 괄호 제거한 본체만 비교
  const base = u.replace(/\([^)]+\)/g, "").trim();
  if (capitalByName.includes(base)) return true;

  return null; // 모름(판정 불가)
}

// 6) 최종 수도권 판정: region이 있으면 우선 쓰되, 캠퍼스 예외는 대학명으로 덮어씀
function isCapitalRegion(rec) {
  const reg = (rec.region || "").trim();
  const byRegion = (reg === "서울" || reg === "경기" || reg === "인천");

  const byUniv = inferCapitalByUniv(rec.univ); // true/false/null

  // 캠퍼스 예외처럼 "대학명이 명확히 말해주는 경우"는 대학명 판정 우선
  if (byUniv === true) return true;
  if (byUniv === false) return false;

  // 대학명으로 판단 못 하면 지역값 사용
  return byRegion;
}

// 7) 특목대 판정(대학명 정규화 후 베이스명 비교)
function isSpecialPurposeUniv(univRaw) {
  const u = normalizeUnivName(univRaw);
  const base = u.replace(/\([^)]+\)/g, "").trim();

  // 영어/한글 혼용 대응(원하면 더 보강)
  const key = base.toUpperCase();
  if (key === "KAIST") return true;
  if (key === "GIST") return true;
  if (key === "DGIST") return true;
  if (key === "UNIST") return true;

  // 한글 명칭들
  if (base.includes("포스텍")) return true;
  if (base.includes("한국에너지공대")) return true;
  if (base.includes("경찰대")) return true;
  if (base.includes("육사")) return true;
  if (base.includes("해사")) return true;
  if (base.includes("공사")) return true;
  if (base.includes("국간사")) return true;

  // 혹시 리스트로 관리하고 싶으면 아래도 병행
  return SPECIAL_PURPOSE_UNIVS.includes(base);
}

    
    function renderFullReport(records) {
      plotsData = {};
      plotInitialized = {};
      currentGradeType = "all_subj";

      const univs = unique(records.map((r) => r.univ));
      const depts = unique(records.map((r) => r.dept));
      const apptypes = unique(records.map((r) => r.apptype));
      const subtypes = unique(records.map((r) => r.subtype));

      const header = `
        <div class="fixed-header">
          <div class="header-content">
            <div class="header-top">
              <div class="site-title">modified by KO</div>
            </div>
            <h2 class="university-title">수시 입시 결과 통계 프로그램 [풍무고등학교]</h2>

            <div class="controls-legend-wrapper" style="display:flex;flex-wrap:wrap;gap:12px;align-items:center;">
              <div class="grade-toggle-container" style="background:#f1eee7;border:1px solid var(--border);border-radius:12px;padding:10px;">
                <button id="btn-conv" class="grade-toggle-btn">환산등급</button>
                <button id="btn-all" class="grade-toggle-btn active">전교과100 등급</button>
              </div>

              <div class="legend-container" style="background:#f1eee7;border:1px solid var(--border);border-radius:12px;padding:10px;">
                <div class="legend-items-wrapper" style="display:flex;flex-wrap:wrap;gap:10px;align-items:center;">
                  <div class="legend-item" style="display:inline-flex;align-items:center;gap:6px;">
                    <span class="legend-marker" style="font-size:18px;color:#5f8669;">&#9679;</span><span>합격 (Y축 상단)</span>
                  </div>
                  <div class="legend-item" style="display:inline-flex;align-items:center;gap:6px;">
                    <span class="legend-marker" style="font-size:18px;color:#7cab7c;">&#9650;</span><span>충원합격 (Y축 중앙)</span>
                  </div>
                  <div class="legend-item" style="display:inline-flex;align-items:center;gap:6px;">
                    <span class="legend-marker" style="font-size:18px;color:#d07a5c;">&#10006;</span><span>불합격 (Y축 하단)</span>
                  </div>
                </div>
                <div class="axis-label" style="font-size:13px;color:var(--muted);display:flex;align-items:center;gap:6px;margin-top:6px;">
                  <span>↔</span><span id="grade-label">전교과100 등급</span> (1~9)
                </div>
              </div>
            </div>
          </div>
        </div>
      `;

      const layout = `
        <div class="layout">
          <aside class="toc-container">
            <div class="toc-header" style="font-weight:800;margin-bottom:10px;font-size:16px;">목차</div>
            <div id="toc-content"></div>
          </aside>
          <main class="main-content" id="content-area"></main>
        </div>
      `;

      reportEl.hidden = false;
      reportEl.innerHTML = header + layout;

      const contentEl = document.getElementById("content-area");
      let plotCounter = 1;
      
contentEl.insertAdjacentHTML("beforeend", `
  <div class="dept-container" style="padding:14px 18px;background:#fff;border:1px solid var(--border);">
    <div style="font-weight:900;font-size:18px;margin:0 0 6px;">보고서</div>
    <div style="color:var(--muted);font-size:13px;line-height:1.4;">
      아래는 업로드한 엑셀 데이터를 기반으로 자동 생성된 통계/시각화입니다.
    </div>
  </div>
`);

      // 출력 기준 표
      // 출력 기준 표
      const filterSummary = `
        <div class="dept-container" style="margin-bottom:16px;">
          <div class="print-grade-line">
            출력 기준: <span id="print-grade-text">전교과100 등급</span>
          </div>
          총 ${records.length}건 · 대학 ${univs.length} · 모집단위 ${depts.length} · 전형유형 ${apptypes.length} · 전형 ${subtypes.length}
        </div>
      `;
      contentEl.insertAdjacentHTML("beforeend", filterSummary);

      // 전체 요약
      const overallBlock = buildPlotBlock(records, plotCounter, "전체 데이터", true, true, true, true);
      plotsData[plotCounter] = overallBlock.data;

      contentEl.insertAdjacentHTML("beforeend", `
        <div class="dept-container" id="overall-summary">
          <div class="dept-header" style="border-bottom:2px solid #e74c3c;">전체 데이터 요약</div>
          ${overallBlock.html}
        </div>
      `);
      plotCounter++;

     // ✅ 서울+수도권(지역/대학명) + 특목대까지 같이 포함
const capitalRecords = records.filter(r => isCapitalRegion(r) || isSpecialPurposeUniv(r.univ));


// “상위권 대학”만 보고 싶으면 여기서 한번 더 필터(없으면 수도권 전체로)
const capitalTopTier = capitalRecords.filter(r => {
  const base = normalizeUnivName(r.univ).replace(/\([^)]+\)/g, "").trim();
  return TOP_TIER_UNIVS.includes(base);
});

const capitalTarget = capitalTopTier.length ? capitalTopTier : capitalRecords;

const capitalBlock = buildPlotBlock(capitalTarget, plotCounter, "서울+수도권", true, true, true, true);
plotsData[plotCounter] = capitalBlock.data;

contentEl.insertAdjacentHTML("beforeend", `
  <div class="dept-container" id="capital-summary">
    <div class="dept-header" style="border-bottom:2px solid #2c3e50;">서울+수도권 대학 지원 및 합/불 현황</div>
    <div style="color:var(--muted);font-size:13px;margin-bottom:10px;">
      기준: (1) 지역=서울/경기/인천 또는 (2) 대학명 보정(캠퍼스 예외 포함) · 대상 ${capitalTarget.length}건
      ${capitalTopTier.length ? " · (상위권 대학 리스트 적용)" : ""}
    </div>
    ${capitalBlock.html}
  </div>
`);
plotCounter++;


// ✅ 특목대 섹션
const specialRecords = records.filter(r => isSpecialPurposeUniv(r.univ));

const specialBlock = buildPlotBlock(specialRecords, plotCounter, "특수목적대학", true, true, true, true);
plotsData[plotCounter] = specialBlock.data;

contentEl.insertAdjacentHTML("beforeend", `
  <div class="dept-container" id="special-summary">
    <div class="dept-header" style="border-bottom:2px solid #8e44ad;">특수목적대학 지원 및 합/불 현황</div>
    <div style="color:var(--muted);font-size:13px;margin-bottom:10px;">
      기준: 특성화 이공계/사관학교/경찰대 등 · 대상 ${specialRecords.length}건
    </div>
    ${specialBlock.html}
  </div>
`);
plotCounter++;

      
      // TOP20
      contentEl.insertAdjacentHTML("beforeend", `
        <div class="dept-container" id="univ-top-global">
          <div class="dept-header">지원 상위 대학 TOP 20 합/충원/불합격</div>
          <div style="border:1px solid var(--border);border-radius:12px;padding:12px;">
            <div id="univ-top-chart" class="plot-container" style="height:420px;"></div>
          </div>
        </div>
      `);

      // 대학별 섹션
      univs.forEach((univ, uIdx) => {
        const dfUniv = records.filter((r) => r.univ === univ);

        let html = `
          <div class="dept-container" id="univ-${uIdx + 1}">
            <div class="dept-header">${univ}</div>
        `;

        // 전형유형별 요약
        const apptypesAll = unique(dfUniv.map((r) => r.apptype));
        if (apptypesAll.length) {
          html += `
            <div id="apptype-summary-${uIdx + 1}" style="border:1px solid #e4ddcf;border-radius:12px;padding:14px;background:#fff;margin-bottom:14px;">
              <div style="font-weight:700;font-size:17px;margin-bottom:10px;">전형유형별 요약</div>
          `;
          apptypesAll.forEach((ap, aIdx) => {
            const subset = dfUniv.filter((r) => r.apptype === ap);
            const block = buildPlotBlock(subset, plotCounter, ap, true);
            html += `
              <div id="apptype-${uIdx + 1}-${aIdx + 1}" style="border:1px solid #e4ddcf;border-radius:12px;padding:14px;background:#fefefe;margin:10px 0 0 8px;">
                <div style="font-weight:700;font-size:16px;margin-bottom:8px;">${ap}</div>
                ${block.html}
              </div>
            `;
            plotsData[plotCounter] = block.data;
            plotCounter++;
          });
          html += `</div>`;
        }

        // 세부유형별 요약
        const subtypesAll = unique(dfUniv.map((r) => r.subtype));
        if (subtypesAll.length) {
          html += `
            <div id="summary-container-${uIdx + 1}" style="border:1px solid #e4ddcf;border-radius:12px;padding:14px;background:#fff;margin-bottom:14px;">
              <div style="font-weight:700;font-size:17px;margin-bottom:10px;">세부유형별 요약</div>
          `;
          subtypesAll.forEach((st, sIdx) => {
            const subset = dfUniv.filter((r) => r.subtype === st);
            const block = buildPlotBlock(subset, plotCounter, st, true);
            html += `
              <div id="subtype-summary-${uIdx + 1}-${sIdx + 1}" style="border:1px solid #e4ddcf;border-radius:12px;padding:14px;background:#fefefe;margin:10px 0 0 8px;">
                <div style="font-weight:700;font-size:16px;margin-bottom:8px;">${st}</div>
                ${block.html}
              </div>
            `;
            plotsData[plotCounter] = block.data;
            plotCounter++;
          });
          html += `</div>`;
        }

        // 모집단위 상세
        const univDepts = unique(dfUniv.map((r) => r.dept));
        univDepts.forEach((dept, dIdx) => {
          const dfDept = dfUniv.filter((r) => r.dept === dept);

          html += `
            <div id="dept-container-${uIdx + 1}-${dIdx + 1}" style="border:1px solid #e4ddcf;border-radius:12px;padding:14px;background:#fff;margin-bottom:14px;">
              <!-- ✅ buildTOC가 찾는 .subtype-header 클래스 반드시 포함 -->
              <div class="subtype-header" style="font-weight:700;font-size:16px;margin-bottom:10px;color:#34495e;">
                ${dIdx + 1}) ${dept}
              </div>
          `;

          const deptSubtypes = unique(dfDept.map((r) => r.subtype));
          deptSubtypes.forEach((st, sIdx) => {
            const subset = dfDept.filter((r) => r.subtype === st);
            if (!subset.length) return;
            const block = buildPlotBlock(subset, plotCounter, st, true);
            html += `
              <div id="subtype-${uIdx + 1}-${dIdx + 1}-${sIdx + 1}" style="border:1px solid #e4ddcf;border-radius:12px;padding:14px;background:#fefefe;margin:10px 0 0 10px;">
                <div style="font-weight:700;font-size:15px;margin-bottom:8px;">${sIdx + 1}) ${st}</div>
                ${block.html}
              </div>
            `;
            plotsData[plotCounter] = block.data;
            plotCounter++;
          });

          html += `</div>`;
        });

        html += `</div>`;
        contentEl.insertAdjacentHTML("beforeend", html);
      });

      bindGradeToggle();
      initPlots();
      buildTOC();
      syncStickyTop();
    }

    function syncStickyTop() {
      const header = document.querySelector(".fixed-header");
      if (!header) return;
      const h = header.offsetHeight || 0;
      const top = Math.max(160, h + 16);
      document.documentElement.style.setProperty("--stickyTop", top + "px");
    }
    window.addEventListener("resize", syncStickyTop);
  </script>

  <script>
    function buildPlotBlock(dataArr, plotId, title, showStats = true, includeHist = false, includeBands = false, includeApptype = false) {
      const convStats = computeStats(dataArr, "conv_grade");
      const allStats  = computeStats(dataArr, "all_subj_grade");
      const convDetail = computeAdditionalStats(dataArr, "conv_grade");
      const allDetail  = computeAdditionalStats(dataArr, "all_subj_grade");
      const plotData = createPlotData(dataArr);

      const statsHtmlConv = showStats ? createStatsHtml(convStats) : "";
      const statsHtmlAll  = showStats ? createStatsHtml(allStats) : "";
      const detailConv = showStats ? createDetailTable(convDetail, "환산등급") : "";
      const detailAll  = showStats ? createDetailTable(allDetail, "전교과등급") : "";

      let extraHtml = "";

      if (includeHist) {
        extraHtml += `
          <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:12px;margin-top:10px;">
            <div style="border:1px solid var(--border);border-radius:12px;padding:12px;">
              <h3 style="margin:0 0 8px;font-size:15px;">전교과등급 히스토그램</h3>
              <div id="hist-all-${plotId}" class="plot-container" style="height:260px;"></div>
            </div>
            <div style="border:1px solid var(--border);border-radius:12px;padding:12px;">
              <h3 style="margin:0 0 8px;font-size:15px;">환산등급 히스토그램</h3>
              <div id="hist-conv-${plotId}" class="plot-container" style="height:260px;"></div>
            </div>
          </div>
        `;
      }

      if (includeBands) {
        extraHtml += `
          <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:12px;margin-top:10px;">
            <div style="border:1px solid var(--border);border-radius:12px;padding:12px;">
              <h3 style="margin:0 0 8px;font-size:15px;">전교과 등급대별 합격/불합격</h3>
              <div id="band-bar-${plotId}" class="plot-container" style="height:280px;"></div>
            </div>
            <div style="border:1px solid var(--border);border-radius:12px;padding:12px;">
              <h3 style="margin:0 0 8px;font-size:15px;">등급대별 통계</h3>
              <div id="band-table-${plotId}"></div>
            </div>
          </div>
        `;
      }

      if (includeApptype) {
        extraHtml += `
          <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:12px;margin-top:10px;">
            <div style="border:1px solid var(--border);border-radius:12px;padding:12px;">
              <h3 style="margin:0 0 8px;font-size:15px;">전형유형별 합/불 현황</h3>
              <div id="apptype-bar-${plotId}" class="plot-container" style="height:280px;"></div>
            </div>
            <div style="border:1px solid var(--border);border-radius:12px;padding:12px;">
              <h3 style="margin:0 0 8px;font-size:15px;">전형유형별 통계</h3>
              <div id="apptype-table-${plotId}"></div>
            </div>
          </div>
        `;
      }

      const html = `
        <div style="display:flex;flex-direction:column;gap:10px;">
          <div id="conv-stats-${plotId}" style="display:none;flex-wrap:wrap;gap:8px;">${statsHtmlConv}</div>
          <div id="all-stats-${plotId}" style="display:flex;flex-wrap:wrap;gap:8px;">${statsHtmlAll}</div>

          <div class="plot-container" id="plot-${plotId}" style="width:100%;height:220px;"></div>

          <div id="conv-detail-${plotId}" style="display:none;">${detailConv}</div>
          <div id="all-detail-${plotId}" style="display:block;">${detailAll}</div>

          ${extraHtml}
        </div>
      `;

      return { html, data: plotData };
    }

    function createPlotData(dataArr) {
const studentLabel = (r) => {
  // 이름 마스킹: 가운데 전부 * (예: 고***재, 3***4)
  const maskName = (name) => {
    name = (name || "").trim();
    if (!name) return "";

    // 공백 포함 이름(예: "홍 길동")도 처리
    const raw = name.replace(/\s+/g, "");
    const len = raw.length;

    if (len === 1) return raw;                 // "고"
    if (len === 2) return raw[0] + "*";        // "고*"
    return raw[0] + "*".repeat(len - 2) + raw[len - 1]; // "고***재"
  };

  // 학년-반-번호는 개인정보 민감도 낮지만, 외부용이면 노출 최소화 권장
  // → 필요하면 켜고 끌 수 있게 옵션화
  const SHOW_ID = false; // true로 바꾸면 (학년-반-번호) 표시

  const masked = maskName(r.student_name);
  const g = (r.grade || "").trim();
  const c = (r.class_no || "").trim();
  const n = (r.student_no || "").trim();
  const tail = [g, c, n].filter(Boolean).join("-");

  if (!masked && !(SHOW_ID && tail)) return "";
  if (SHOW_ID && tail) return `학생: ${masked || "익명"} (${tail})`;
  return `학생: ${masked || "익명"}`;
};


      const convTraces = RESULT_ORDER.map((res) => {
        const rows = dataArr.filter((r) => r.result === res && r.conv_grade !== null);
        return {
          x: rows.map((r) => r.conv_grade),
          y: rows.map(() => Y_POS[res] ?? 0),
          type: "scatter",
          mode: "markers",
          name: res,
          marker: {
            color: COLOR_MAP[res].fill,
            line: { color: COLOR_MAP[res].border, width: 1.5 },
            symbol: SYMBOL_MAP[res] || "circle",
            size: 12,
          },
          customdata: rows.map((r) => [r.dept, r.subtype, r.univ, studentLabel(r)]),
          hovertemplate:
            "환산등급: %{x}<br>대학: %{customdata[2]}<br>모집단위: %{customdata[0]}<br>세부유형: %{customdata[1]}<br>%{customdata[3]}<extra></extra>",
          showlegend: false,
        };
      });

      const allTraces = RESULT_ORDER.map((res) => {
        const rows = dataArr.filter((r) => r.result === res && r.all_subj_grade !== null);
        return {
          x: rows.map((r) => r.all_subj_grade),
          y: rows.map(() => Y_POS[res] ?? 0),
          type: "scatter",
          mode: "markers",
          name: res,
          marker: {
            color: COLOR_MAP[res].fill,
            line: { color: COLOR_MAP[res].border, width: 1.5 },
            symbol: SYMBOL_MAP[res] || "circle",
            size: 12,
          },
          customdata: rows.map((r) => [r.dept, r.subtype, r.univ, studentLabel(r)]),
          hovertemplate:
            "전교과등급: %{x}<br>대학: %{customdata[2]}<br>모집단위: %{customdata[0]}<br>세부유형: %{customdata[1]}<br>%{customdata[3]}<extra></extra>",
          showlegend: false,
        };
      });

      return { convTraces, allTraces };
    }

    function createStatsHtml(stats) {
      const items = [];
      items.push(`<div style="padding:7px 11px;border-radius:8px;background:#e4e0d7;border:1px solid #d6cebf;font-size:13px;font-weight:800;">총 ${stats.total_count}명</div>`);

      if (stats.all_pass_count !== undefined) {
        items.push(`<div style="padding:7px 11px;border-radius:8px;background:#eef0eb;border:1px solid #d6cebf;font-size:13px;border-left:4px solid var(--primary);">
          합격(전체): ${stats.all_pass_count}명 (${stats.all_pass_rate || "0%"}), 범위 ${fmt(stats.all_pass_min)}~${fmt(stats.all_pass_max)}, 평균 ${fmt(stats.all_pass_mean)}
        </div>`);
      }

      items.push(`<div style="padding:7px 11px;border-radius:8px;background:#eef0eb;border:1px solid #d6cebf;font-size:13px;border-left:4px solid var(--primary);">
        합격(일반): ${stats.pass_count}명 (${stats.pass_rate})
      </div>`);

      items.push(`<div style="padding:7px 11px;border-radius:8px;background:#eef0eb;border:1px solid #d6cebf;font-size:13px;border-left:4px solid #7cab7c;">
        충원합격: ${stats.waitlist_count}명 (${stats.waitlist_rate})
      </div>`);

      const failRate = stats.total_count ? ((stats.fail_count / stats.total_count) * 100).toFixed(1) + "%" : "0.0%";
      items.push(`<div style="padding:7px 11px;border-radius:8px;background:#eef0eb;border:1px solid #d6cebf;font-size:13px;border-left:4px solid #d26c5b;">
        불합격: ${stats.fail_count}명 (${failRate})
      </div>`);

      return items.join("");
    }

    function createDetailTable(detail, title) {
      const rows = RESULT_ORDER.map((res) => {
        const d = detail[res] || {};
        if (!d.count) return `<tr><td>${res}</td><td colspan="6">데이터 없음</td></tr>`;
        return `<tr>
          <td>${res}</td>
          <td>${d.count}명</td>
          <td>${fmt(d.mean)}</td>
          <td>${fmt(d.std)}</td>
          <td>${fmt(d.min)} ~ ${fmt(d.max)}</td>
          <td>${fmt(d.median)}</td>
          <td>${fmtRange(d.q1, d.q3)}</td>
        </tr>`;
      }).join("");

      return `
        <div style="border:1px solid var(--border);border-radius:12px;padding:12px;margin-top:10px;">
          <h3 style="margin:0 0 8px;font-size:15px;">${title} 상세 통계</h3>
          <table style="width:100%;border-collapse:collapse;">
            <thead>
              <tr>
                <th style="border:1px solid #e4ddcf;padding:7px;background:#f1ede5;">결과</th>
                <th style="border:1px solid #e4ddcf;padding:7px;background:#f1ede5;">인원</th>
                <th style="border:1px solid #e4ddcf;padding:7px;background:#f1ede5;">평균</th>
                <th style="border:1px solid #e4ddcf;padding:7px;background:#f1ede5;">표준편차</th>
                <th style="border:1px solid #e4ddcf;padding:7px;background:#f1ede5;">범위</th>
                <th style="border:1px solid #e4ddcf;padding:7px;background:#f1ede5;">중앙값</th>
                <th style="border:1px solid #e4ddcf;padding:7px;background:#f1ede5;">1Q-3Q</th>
              </tr>
            </thead>
            <tbody>${rows}</tbody>
          </table>
        </div>
      `;
    }

    function computeStats(dataArr, gradeKey) {
      const total = dataArr.length;
      const counts = RESULT_ORDER.reduce((acc, r) => {
        acc[r] = dataArr.filter((d) => d.result === r).length;
        return acc;
      }, {});

      const passData = dataArr
        .filter((d) => d.result === "합격" || d.result === "충원합격")
        .map((d) => d[gradeKey])
        .filter((v) => v !== null);

      const stats = {
        total_count: total,
        pass_count: counts["합격"] || 0,
        waitlist_count: counts["충원합격"] || 0,
        fail_count: counts["불합격"] || 0,
      };

      stats.all_pass_count = stats.pass_count + stats.waitlist_count;
      stats.pass_rate = total ? ((stats.pass_count / total) * 100).toFixed(1) + "%" : "0.0%";
      stats.waitlist_rate = total ? ((stats.waitlist_count / total) * 100).toFixed(1) + "%" : "0.0%";
      stats.all_pass_rate = total ? ((stats.all_pass_count / total) * 100).toFixed(1) + "%" : "0.0%";

      if (passData.length) {
        stats.all_pass_min = Math.min(...passData);
        stats.all_pass_max = Math.max(...passData);
        stats.all_pass_mean = mean(passData);
      }
      return stats;
    }

    function computeAdditionalStats(dataArr, key) {
      const out = {};
      RESULT_ORDER.forEach((res) => {
        const arr = dataArr.filter((d) => d.result === res).map((d) => d[key]).filter((v) => v !== null);
        if (!arr.length) { out[res] = { count: 0 }; return; }
        out[res] = {
          count: arr.length,
          mean: mean(arr),
          std: stddev(arr),
          min: Math.min(...arr),
          max: Math.max(...arr),
          median: percentile(arr, 50),
          q1: percentile(arr, 25),
          q3: percentile(arr, 75),
        };
      });
      return out;
    }

    function mean(arr) { return arr.reduce((a, b) => a + b, 0) / arr.length; }
    function stddev(arr) {
      if (arr.length < 2) return 0;
      const m = mean(arr);
      return Math.sqrt(arr.reduce((s, v) => s + Math.pow(v - m, 2), 0) / (arr.length - 1));
    }
    function percentile(arr, p) {
      if (!arr.length) return 0;
      const s = [...arr].sort((a, b) => a - b);
      const rank = (p / 100) * (s.length - 1);
      const l = Math.floor(rank);
      const h = Math.ceil(rank);
      if (l === h) return s[l];
      const w = rank - l;
      return s[l] * (1 - w) + s[h] * w;
    }
    function fmt(v) { return v === undefined || v === null || Number.isNaN(v) ? "-" : Number(v).toFixed(2); }
    function fmtRange(a, b) { if ([a, b].some((x) => x === undefined || x === null || Number.isNaN(x))) return "-"; return `${Number(a).toFixed(2)} ~ ${Number(b).toFixed(2)}`; }

    function createLayout() {
      return {
        height: 220,
        autosize: true,
        margin: { t: 12, b: 45, l: 55, r: 25 },
        xaxis: {
          range: [0.5, 9.5],
          tickmode: "array",
          tickvals: [1,2,3,4,5,6,7,8,9],
          ticktext: ["1","2","3","4","5","6","7","8","9"],
          title: "등급"
        },
        yaxis: {
          range: [-0.05, 0.05],
          tickmode: "array",
          tickvals: [0.01, 0.0, -0.03],
          ticktext: ["", "", ""],
          showgrid: false,
          zeroline: false
        },
        showlegend: false,
        plot_bgcolor: "#fff",
        paper_bgcolor: "#fff",
      };
    }

    function initPlots() {
      document.querySelectorAll(".plot-container[id^='plot-']").forEach((div) => {
        const id = div.id.split("-")[1];
        const data = plotsData[id];
        if (!data) return;
        const traces = currentGradeType === "conv" ? data.convTraces : data.allTraces;
        Plotly.newPlot(div, traces, createLayout(), { displayModeBar: false, responsive: true });
        plotInitialized[id] = true;
      });

      // 전체 요약 블록에만 붙는 추가 시각화
      Object.keys(plotsData).forEach((pid) => {
        if (document.getElementById(`hist-all-${pid}`)) {
          renderHist(lastRecords, "all_subj_grade", `hist-all-${pid}`, "전교과등급");
        }
        if (document.getElementById(`hist-conv-${pid}`)) {
          renderHist(lastRecords, "conv_grade", `hist-conv-${pid}`, "환산등급");
        }
        if (document.getElementById(`band-bar-${pid}`)) {
          renderGradeBands(lastRecords, "all_subj_grade", pid);
        }
        if (document.getElementById(`apptype-bar-${pid}`)) {
          renderApptypeStats(lastRecords, pid);
        }
      });

      renderUnivTop(lastRecords);
    }

    function updateAllPlots() {
      document.querySelectorAll(".plot-container[id^='plot-']").forEach((div) => {
        const id = div.id.split("-")[1];
        const data = plotsData[id];
        if (!data || !plotInitialized[id]) return;
        const traces = currentGradeType === "conv" ? data.convTraces : data.allTraces;
        Plotly.react(div, traces, createLayout(), { displayModeBar: false, responsive: true });
      });
    }

    function bindGradeToggle() {
      const btnConv = document.getElementById("btn-conv");
      const btnAll  = document.getElementById("btn-all");
      btnConv.onclick = () => switchGrade("conv");
      btnAll.onclick  = () => switchGrade("all_subj");
    }

    function switchGrade(type) {
      if (currentGradeType === type) return;
      currentGradeType = type;

      document.getElementById("btn-conv").classList.toggle("active", type === "conv");
      document.getElementById("btn-all").classList.toggle("active", type === "all_subj");

      document.getElementById("grade-label").textContent = type === "conv" ? "환산등급" : "전교과100 등급";
      const pg = document.getElementById("print-grade-text");
      if (pg) pg.textContent = type === "conv" ? "환산등급" : "전교과100 등급";

      document.querySelectorAll("[id^='conv-stats-']").forEach((el) => el.style.display = type === "conv" ? "flex" : "none");
      document.querySelectorAll("[id^='all-stats-']").forEach((el)  => el.style.display = type === "all_subj" ? "flex" : "none");
      document.querySelectorAll("[id^='conv-detail-']").forEach((el)=> el.style.display = type === "conv" ? "block" : "none");
      document.querySelectorAll("[id^='all-detail-']").forEach((el) => el.style.display = type === "all_subj" ? "block" : "none");

      updateAllPlots();
    }

    function buildTOC() {
      const toc = document.getElementById("toc-content");
      let html = "";

      document.querySelectorAll(".dept-container").forEach((container) => {
        const header = container.querySelector(".dept-header");
        if (!header) return;

        const id = container.id;
        html += `<div style="font-weight:700;cursor:pointer;padding:6px;border-radius:8px;color:var(--primary-dark);" onclick="scrollToElement('${id}')">${header.textContent}</div>`;

        const apSummary = container.querySelector("[id^='apptype-summary-']");
        if (apSummary) html += `<div style="margin-left:10px;"><div style="font-size:13px;cursor:pointer;padding:4px 6px;border-radius:6px;" onclick="scrollToElement('${apSummary.id}')">전형유형별 요약</div></div>`;

        const stSummary = container.querySelector("[id^='summary-container-']");
        if (stSummary) html += `<div style="margin-left:10px;"><div style="font-size:13px;cursor:pointer;padding:4px 6px;border-radius:6px;" onclick="scrollToElement('${stSummary.id}')">세부유형별 요약</div></div>`;

        // ✅ 모집단위(학과)까지 목차로 내리기
        container.querySelectorAll("[id^='dept-container-']").forEach((deptEl) => {
          const deptHeader = deptEl.querySelector(".subtype-header"); // 위에서 넣은 클래스
          if (!deptHeader) return;
          html += `<div style="margin-left:14px;font-size:12.5px;cursor:pointer;padding:4px 6px;border-radius:6px;color:#2f3c32;" onclick="scrollToElement('${deptEl.id}')">- ${deptHeader.textContent}</div>`;
        });
      });
      toc.innerHTML = html;
    }

    function scrollToElement(id) {
      const el = document.getElementById(id);
      if (!el) return;
      const headerHeight = document.querySelector(".fixed-header")?.offsetHeight || 0;
      const top = el.getBoundingClientRect().top + window.pageYOffset - headerHeight - 10;
      window.scrollTo({ top, behavior: "smooth" });
    }
    window.scrollToElement = scrollToElement;

    function makeHistogramSeries(records, key) {
      const passArr = records
        .filter((r) => r.result === "합격" || r.result === "충원합격")
        .map((r) => r[key]).filter((v) => v !== null);
      const failArr = records
        .filter((r) => r.result === "불합격")
        .map((r) => r[key]).filter((v) => v !== null);

      const edges = [];
      for (let v = BINS.start; v < BINS.end; v += BINS.size) edges.push(Number(v.toFixed(4)));
      edges.push(BINS.end);

      const bins = edges.length - 1;
      const passCounts = new Array(bins).fill(0);
      const failCounts = new Array(bins).fill(0);
      const center = [];
      for (let i = 0; i < bins; i++) center.push((edges[i] + edges[i + 1]) / 2);

      const fillCounts = (arr, target) => {
        arr.forEach((v) => {
          if (v < BINS.start || v > BINS.end) return;
          const idx = Math.min(Math.floor((v - BINS.start) / BINS.size), bins - 1);
          target[idx] += 1;
        });
      };
      fillCounts(passArr, passCounts);
      fillCounts(failArr, failCounts);

      return { center, passCounts, failCounts };
    }

    function makeGradeBandStats(records, key) {
      const bands = [
        { label: "1등급대", from: 1, to: 1.999 },
        { label: "2등급대", from: 2, to: 2.999 },
        { label: "3등급대", from: 3, to: 3.999 },
        { label: "4등급대", from: 4, to: 4.999 },
        { label: "5등급대", from: 5, to: 5.999 },
        { label: "6등급대", from: 6, to: 6.999 },
        { label: "7등급대", from: 7, to: 7.999 },
        { label: "8등급대", from: 8, to: 8.999 },
        { label: "9등급대", from: 9, to: 9.999 },
      ];
      return bands.map((b) => {
        const inBand = records.filter((r) => r[key] !== null && r[key] >= b.from && r[key] <= b.to);
        const pass = inBand.filter((r) => r.result === "합격" || r.result === "충원합격").length;
        const fail = inBand.filter((r) => r.result === "불합격").length;
        const total = pass + fail;
        return { label: b.label, pass, fail, total, passRate: total ? (pass / total) * 100 : 0 };
      });
    }

    function renderGradeBands(records, key, targetPlotId) {
      const stats = makeGradeBandStats(records, key);
      const labels = stats.map((s) => s.label);
      const passCounts = stats.map((s) => s.pass);
      const failCounts = stats.map((s) => s.fail);
      const hasData = stats.some((s) => s.total > 0);

      const barEl = document.getElementById(`band-bar-${targetPlotId}`);
      const tableEl = document.getElementById(`band-table-${targetPlotId}`);

      if (barEl) {
        if (!hasData) {
          barEl.innerHTML = '<div class="empty">데이터 없음</div>';
        } else {
          Plotly.newPlot(barEl, [
            { x: labels, y: passCounts, type: "bar", name: "합격(충원포함)", marker: { color: COLOR_MAP["합격"].border } },
            { x: labels, y: failCounts, type: "bar", name: "불합격", marker: { color: COLOR_MAP["불합격"].border } },
          ], {
            height: 280,
            barmode: "stack",
            margin: { t: 20, b: 40, l: 45, r: 20 },
            yaxis: { title: "인원" },
          }, { displayModeBar: false, responsive: true });
        }
      }

      if (tableEl) {
        const rows = stats.map((s) => {
          if (!s.total) return `<tr><td>${s.label}</td><td colspan="4">데이터 없음</td></tr>`;
          return `<tr><td>${s.label}</td><td>${s.pass}</td><td>${s.fail}</td><td>${s.total}</td><td>${s.passRate.toFixed(1)}%</td></tr>`;
        }).join("");
        tableEl.innerHTML = `<table class="stats-table">
          <thead><tr><th>등급대</th><th>합격</th><th>불합격</th><th>총원</th><th>합격률</th></tr></thead>
          <tbody>${rows}</tbody>
        </table>`;
      }
    }

    function makeApptypeStats(records) {
      const groups = {};
      records.forEach((r) => {
        const key = r.apptype || "미상";
        if (!groups[key]) groups[key] = { total: 0, pass: 0, wait: 0, fail: 0 };
        groups[key].total += 1;
        if (r.result === "합격") groups[key].pass += 1;
        else if (r.result === "충원합격") groups[key].wait += 1;
        else if (r.result === "불합격") groups[key].fail += 1;
      });
      return Object.entries(groups).map(([apptype, g]) => {
        const total = g.total || 1;
        return {
          apptype,
          total: g.total,
          pass: g.pass,
          wait: g.wait,
          fail: g.fail,
          passRate: (g.pass / total) * 100,
          waitRate: (g.wait / total) * 100,
          failRate: (g.fail / total) * 100,
        };
      }).sort((a, b) => b.total - a.total);
    }

    function renderApptypeStats(records, plotId) {
      const stats = makeApptypeStats(records);
      const labels = stats.map((s) => s.apptype);
      const passCounts = stats.map((s) => s.pass);
      const waitCounts = stats.map((s) => s.wait);
      const failCounts = stats.map((s) => s.fail);
      const hasData = stats.some((s) => s.total > 0);

      const barEl = document.getElementById(`apptype-bar-${plotId}`);
      const tableEl = document.getElementById(`apptype-table-${plotId}`);

      if (barEl) {
        if (!hasData) {
          barEl.innerHTML = '<div class="empty">데이터 없음</div>';
        } else {
          Plotly.newPlot(barEl, [
            { y: labels, x: passCounts, type: "bar", name: "합격", orientation: "h", marker: { color: COLOR_MAP["합격"].border } },
            { y: labels, x: waitCounts, type: "bar", name: "충원합격", orientation: "h", marker: { color: COLOR_MAP["충원합격"].border } },
            { y: labels, x: failCounts, type: "bar", name: "불합격", orientation: "h", marker: { color: COLOR_MAP["불합격"].border } },
          ], {
            height: Math.max(240, 26 * labels.length + 80),
            barmode: "stack",
            margin: { t: 20, b: 40, l: 120, r: 20 },
            xaxis: { title: "인원" },
          }, { displayModeBar: false, responsive: true });
        }
      }

      if (tableEl) {
        const rows = stats.map((s) => {
          if (!s.total) return `<tr><td>${s.apptype}</td><td colspan="7">데이터 없음</td></tr>`;
          return `<tr>
            <td>${s.apptype}</td><td>${s.total}</td><td>${s.pass}</td><td>${s.wait}</td><td>${s.fail}</td>
            <td>${s.passRate.toFixed(1)}%</td><td>${s.waitRate.toFixed(1)}%</td><td>${s.failRate.toFixed(1)}%</td>
          </tr>`;
        }).join("");
        tableEl.innerHTML = `<table class="stats-table">
          <thead><tr><th>전형유형</th><th>총원</th><th>합격</th><th>충원합격</th><th>불합격</th><th>합격률</th><th>충원률</th><th>불합격률</th></tr></thead>
          <tbody>${rows}</tbody>
        </table>`;
      }
    }

    function renderUnivTop(records) {
      const univTopEl = document.getElementById("univ-top-chart");
      if (!univTopEl) return;

      const grouped = {};
      records.forEach((r) => {
        const key = r.univ || "미상";
        if (!grouped[key]) grouped[key] = { pass: 0, wait: 0, fail: 0, total: 0 };
        grouped[key].total += 1;
        if (r.result === "합격") grouped[key].pass += 1;
        else if (r.result === "충원합격") grouped[key].wait += 1;
        else if (r.result === "불합격") grouped[key].fail += 1;
      });

      const sorted = Object.entries(grouped)
        .map(([univ, g]) => ({ univ, ...g }))
        .filter((x) => x.total > 0)
        .sort((a, b) => b.total - a.total)
        .slice(0, 20);

      if (!sorted.length) {
        univTopEl.innerHTML = '<div class="empty">데이터 없음</div>';
        return;
      }

      const labelsTop = sorted.map((s) => s.univ);
      const passTop = sorted.map((s) => s.pass);
      const waitTop = sorted.map((s) => s.wait);
      const failTop = sorted.map((s) => s.fail);

      const dynamicHeight = Math.max(360, 26 * labelsTop.length + 110);
      univTopEl.style.height = dynamicHeight + "px";

      Plotly.newPlot(univTopEl, [
        { y: labelsTop, x: passTop, type: "bar", name: "합격", orientation: "h", marker: { color: COLOR_MAP["합격"].border } },
        { y: labelsTop, x: waitTop, type: "bar", name: "충원합격", orientation: "h", marker: { color: COLOR_MAP["충원합격"].border } },
        { y: labelsTop, x: failTop, type: "bar", name: "불합격", orientation: "h", marker: { color: COLOR_MAP["불합격"].border } },
      ], {
        height: dynamicHeight,
        barmode: "stack",
        margin: { t: 24, b: 40, l: 150, r: 24 },
        xaxis: { title: "인원" },
      }, { displayModeBar: false, responsive: true });
    }

    function renderHist(records, key, targetId, title) {
      const el = document.getElementById(targetId);
      if (!el) return;

      const { center, passCounts, failCounts } = makeHistogramSeries(records, key);
      const hasData = passCounts.some((c) => c > 0) || failCounts.some((c) => c > 0);
      if (!hasData) { el.innerHTML = '<div class="empty">데이터 없음</div>'; return; }

      const maxVal = Math.max(...passCounts, ...failCounts, 0);

      Plotly.newPlot(el, [
        { x: center, y: passCounts, type: "bar", name: "합격(충원포함)", marker: { color: COLOR_MAP["합격"].border }, width: BINS.size * 0.9 },
        { x: center, y: failCounts.map((v) => -v), type: "bar", name: "불합격", marker: { color: COLOR_MAP["불합격"].border }, width: BINS.size * 0.9 },
      ], {
        height: 260,
        barmode: "relative",
        bargap: 0.02,
        margin: { t: 20, b: 45, l: 50, r: 20 },
        xaxis: { title: "등급", range: [BINS.start, BINS.end] },
        yaxis: { title: "인원(+합격 / -불합격)", zeroline: true, range: [-maxVal * 1.2, maxVal * 1.2] },
      }, { displayModeBar: false, responsive: true });
    }
  </script>

</body>
</html>
