<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title><?= appTitle ?></title>

  <!-- Plotly (공유뷰어에서도 hover 필요) -->
  <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>

  <style>
    body { margin:0; font-family: system-ui, sans-serif; background:#f6f4ef; color:#2f3c32; }
    .wrap { max-width: 1200px; margin: 18px auto; padding: 0 12px; }
    .card { background:#fff; border:1px solid #d9d2c3; border-radius:14px; padding:16px; box-shadow:0 10px 28px rgba(47,60,50,0.12); }
    .muted { color:#6a7065; font-size:13px; }
    .btn { cursor:pointer; border:1px solid #d9d2c3; background:#eef0eb; padding:10px 14px; border-radius:10px; font-weight:700; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h2 style="margin:0 0 6px;"><?= appTitle ?></h2>
      <div class="row">
        <button class="btn" id="reload">새로고침</button>
        <div class="muted" id="meta"></div>
      </div>
      <div class="muted" id="status" style="margin-top:8px;"></div>
    </div>

    <div style="height:12px;"></div>

    <div class="card" id="app">
      <!-- 여기 아래에 “보고서 화면과 동일한 렌더”를 붙일 예정 -->
      <div class="muted">share.json을 불러오는 중...</div>
    </div>
  </div>

  <script>
    let reportEl = null;

   let reportEl = null;

async function fetchShare() {
  return new Promise((resolve) => {
    google.script.run.withSuccessHandler(resolve).getShareData();
  });
}

document.getElementById("reload").addEventListener("click", load);

async function load() {
  const res = await fetchShare();

  const status = document.getElementById("status");
  const meta   = document.getElementById("meta");
  const app    = document.getElementById("app");

  // 실패 처리
  if (!res || !res.ok) {
    const msg = res?.message || "응답이 없습니다.";
    status.textContent = msg;
    app.innerHTML = `<div class="muted">${msg}</div>`;
    return;
  }

  // 상태 표시
  meta.textContent   = `파일: ${res?.meta?.fileName || "share.json"} · 업데이트: ${res?.meta?.updatedAt || ""}`;
  status.textContent = "데이터 로드 완료";

  // records는 '생성'이 아니라 '읽기'
  const records = Array.isArray(res?.data?.records) ? res.data.records : [];

  if (!records.length) {
    app.innerHTML = `<div class="muted">records가 비어 있습니다. share.json의 records 배열을 확인해 주세요.</div>`;
    return;
  }

  // report 컨테이너 생성 + 렌더
  app.innerHTML = `<section id="report"></section>`;
  reportEl = document.getElementById("report");
  renderFullReport(records);
}

// 최초 1회 로드
load();


      const RESULT_ORDER = ["합격", "충원합격", "불합격"];
    const COLOR_MAP = {
      "합격":   { border: "#5f8669", fill: "rgba(95, 134, 105, 0.30)" },
      "충원합격": { border: "#7cab7c", fill: "rgba(124, 171, 124, 0.28)" },
      "불합격": { border: "#d07a5c", fill: "rgba(208, 122, 92, 0.32)" },
    };
    const SYMBOL_MAP = { "합격": "circle", "충원합격": "triangle-up", "불합격": "x" };
    const Y_POS = { "합격": 0.01, "충원합격": 0.0, "불합격": -0.03 };
    const BINS = { start: 1, end: 9, size: 0.5 };

    // ✅ 특수목적대(포스텍 제외 / 켄텍 포함)
    const SPECIAL_UNIVS = new Set([
      "카이스트","KAIST","한국과학기술원",
      "유니스트","UNIST","울산과학기술원",
      "디지스트","DGIST","대구경북과학기술원",
      "지스트","GIST","광주과학기술원",
      "켄텍","KENTECH","한국에너지공과대학교"
    ]);

    // ✅ 출력용 대학명 보정(사용자 제공 매핑)
    const UNIV_ALIAS_MAP = new Map([
      ["국립한국해양대학교(부산)", "한국해양대"],
      ["한양대학교(ERICA)", "한양대(에)"],
      ["광주여자대학교(광주)", "광주여대"],
      ["중부대학교(고양) - 고양캠퍼스", "중부대(고)"],
      ["중부대학교(금산) - 충청캠퍼스", "중부대"],
      ["동국대학교(WISE)", "동국대(W)"],
      ["중앙대학교(다빈치) - 다빈치캠퍼스", "중앙대(다)"],
      ["중앙대학교(다빈치)", "중앙대(다)"],
      ["건국대학교(글로컬)", "건국대(글)"],
      ["상명대학교(천안)", "상명대(천)"],
      ["한국기술교육대학교(천안)", "한국기술교대"],
      ["한국항공대학교(고양)", "한국항공대"],
      ["홍익대학교(세종)", "홍익대(세)"],
    ]);




       
    // 인쇄 후 클래스 복구
    window.addEventListener("afterprint", () => {
      document.body.classList.remove("print-overall","print-capital","print-full");
    });

    function setStatus(msg, isError = false) {
      statusEl.textContent = msg;
      statusEl.style.color = isError ? "#c0392b" : "#607089";
    }

    function printWithMode(mode){
      if (reportEl.hidden) {
        alert("먼저 보고서를 생성해주세요!");
        return;
      }
      document.body.classList.remove("print-overall","print-capital","print-full");
      if (mode === "overall") document.body.classList.add("print-overall");
      if (mode === "capital") document.body.classList.add("print-capital");
      if (mode === "full") document.body.classList.add("print-full");
      window.print();
    }

function exportShareJSON() {
  if (!lastRecords || !lastRecords.length) {
    alert("먼저 보고서를 생성해주세요!");
    return;
  }

  // ✅ 원본/개인정보를 빼고 “공유용 요약”만 담기
  const payload = buildSharePayload(lastRecords);

  const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json;charset=utf-8" });
  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  const stamp = new Date().toISOString().slice(0,10);
  a.href = url;
  a.download = `susi_report_share_${stamp}.json`;
  document.body.appendChild(a);
  a.click();
  a.remove();

  setTimeout(() => URL.revokeObjectURL(url), 500);
}

// ✅ 공유용 JSON: “대학/전형/결과/등급 통계” 중심 (학생명/학번 등 제거)
function buildSharePayload(records){
  // 1) 전체 카운트
  const total = records.length;

  // 2) 수도권+특목대 합격(충원포함) 대학별 집계(현재 화면 표랑 동일 목적)
  const picked = records.filter(r => isCapitalByRegion(r.region) || isSpecialUniv(r.univ));
  const passPicked = picked.filter(r => r.result === "합격" || r.result === "충원합격");

  const byUniv = {};
  passPicked.forEach(r => {
    const u = r.univ || "미상";
    byUniv[u] = (byUniv[u] || 0) + 1;
  });

  const capital_special_pass_univ = Object.entries(byUniv)
    .map(([univ, passCount]) => ({ univ, passCount }))
    .sort((a,b) => b.passCount - a.passCount || a.univ.localeCompare(b.univ, "ko"));

  // 3) 전형유형별 요약(전체)
  const apptype = {};
  records.forEach(r => {
    const k = r.apptype || "미상";
    if (!apptype[k]) apptype[k] = { total:0, pass:0, wait:0, fail:0 };
    apptype[k].total += 1;
    if (r.result === "합격") apptype[k].pass += 1;
    else if (r.result === "충원합격") apptype[k].wait += 1;
    else if (r.result === "불합격") apptype[k].fail += 1;
  });

  return {
    meta: {
      createdAt: new Date().toISOString(),
      note: "공유용 요약 JSON(개인정보 제거). 원본 엑셀/개별 학생정보는 포함하지 않음."
    },
    totalRecords: total,
    apptypeSummary: apptype,
    capitalAndSpecialPassByUniversity: capital_special_pass_univ
  };
}

    
    async function handleGenerate() {
      const file = fileInput.files[0];
      if (!file) {
        setStatus("엑셀 파일을 선택해주세요.", true);
        return;
      }
      setStatus("엑셀을 읽는 중...");

      try {
        const records = await parseExcel(file);
        if (!records.length) {
          setStatus("유효한 데이터가 없습니다. 필수 컬럼을 확인하세요.", true);
          return;
        }
        lastRecords = records;
        enableJsonExport()
        setStatus(`총 ${records.length}건 로드 완료. 보고서가 생성되었습니다.`);
      } catch (e) {
        console.error(e);
        setStatus("처리 중 오류: " + e.message, true);
      }
    }

    function parseExcel(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();

        reader.onload = (e) => {
          try {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: "array" });
            const sheet = workbook.Sheets[workbook.SheetNames[0]];

            // 첫 2행 스킵
            const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, range: 2 });

            // 형식 판별
            const isAltFormat = (() => {
              const cell = sheet["V1"];
              const val = cell ? String(cell.v || "").trim() : "";
              return val.includes("최종단계");
            })();

            // 기본: result=R(17), all_subj=AG(32), conv=AH(33)
            // 대안: result=V(21), all_subj=R(17), conv=T(19)
            const COL = {
              region: 5,  // F
              univ: 6,    // G
              apptype: 8, // I
              subtype: 10,// K
              dept: 12,   // M
              result: isAltFormat ? 21 : 17,
              all:    isAltFormat ? 17 : 32,
              conv:   isAltFormat ? 19 : 33,
            };

            const records = [];
            rows.forEach((row) => {
              const rawName = safe(row[3]);
              const masked = maskName(rawName);

              const rawUniv = safe(row[COL.univ]);
              const region  = safe(row[COL.region]);

              const rec = {
                grade: safe(row[0]),
                class_no: safe(row[1]),
                student_no: safe(row[2]),
                student_name: masked,          // ✅ 기본 마스킹 적용
                student_name_raw: rawName,     // 내부 참고(표시X)
                region,
                univ_raw: rawUniv,
                univ: normalizeUniversityName(rawUniv, region), // ✅ 출력용 보정명
                apptype: safe(row[COL.apptype]),
                subtype: safe(row[COL.subtype]),
                dept: safe(row[COL.dept]),
                result: normalizeResult(safe(row[COL.result])),
                all_subj_grade: parseGrade(row[COL.all]),
                conv_grade: parseGrade(row[COL.conv]),
              };

              // 필수값 체크
              if (!rec.result || !rec.univ || !rec.dept || !rec.subtype || !rec.apptype) return;
              if (rec.all_subj_grade === null && rec.conv_grade === null) return;

              records.push(rec);
            });

            resolve(records);
          } catch (err) {
            reject(err);
          }
        };

        reader.onerror = (err) => reject(err);
        reader.readAsArrayBuffer(file);
      });
    }

    function safe(v) {
      return v === undefined || v === null ? "" : String(v).trim();
    }

    function parseGrade(v) {
      const n = parseFloat(v);
      return Number.isFinite(n) ? n : null;
    }

    function unique(arr) {
      return Array.from(new Set(arr)).filter(Boolean).sort();
    }

  function normalizeResult(v){
  const s = safe(v);

  // ✅ 반드시 "불합격"을 먼저
  if (s.includes("불합격")) return "불합격";
  if (s.includes("충원")) return "충원합격";
  if (s.includes("합격")) return "합격";

  return s;
}


    function maskName(name){
      const s = safe(name);
      if (!s) return "";
      const chars = Array.from(s);
      if (chars.length === 1) return chars[0] + "*";
      if (chars.length === 2) return chars[0] + "*";
      return chars[0] + "*".repeat(chars.length - 2) + chars[chars.length - 1];
    }

    // ✅ 대학명 보정: (1) 사용자 매핑 우선 (2) (캠퍼스) 첫글자만 축약 (3) 정리
    function normalizeUniversityName(univRaw, region){
      const u0 = safe(univRaw);
      if (!u0) return "";

      // 1) 매핑 우선(완전일치)
      if (UNIV_ALIAS_MAP.has(u0)) return UNIV_ALIAS_MAP.get(u0);

      // 2) 괄호 캠퍼스가 있으면 첫 글자만
      // 예: "고려대학교(세종)" -> "고려대학교(세)"
      // 예: "동국대학교(WISE)" -> "동국대학교(W)" (이미 매핑이 없을 경우)
      let u = u0;

      // 하이픈/캠퍼스 설명 제거 (대략적인 정리)
      // " - 고양캠퍼스" 같은 설명을 떼되, 괄호는 남김
      u = u.replace(/\s*-\s*.*$/g, "").trim();

      // 3) "국립" 같은 접두는 유지/제거는 취향인데, 여기선 유지(사용자 매핑에 국립이 이미 있음)
      // 4) 괄호 처리
      const m = u.match(/^(.+?)\((.+?)\)$/);
      if (m){
        const head = m[1].trim();
        const inside = m[2].trim();
        const first = Array.from(inside)[0] || "";
        return `${head}(${first})`;
      }

      return u;
    }

    // ✅ 서울+수도권 판단: region 최우선
    function isCapitalByRegion(region){
      const r = safe(region);
      return r.includes("서울") || r.includes("경기") || r.includes("인천");
    }

    // ✅ 특목대 포함 판단(출력용 univ 기준)
    function isSpecialUniv(univName){
      const u = safe(univName);
      if (!u) return false;
      // alias로 줄여도 걸리도록
      if (SPECIAL_UNIVS.has(u)) return true;
      // 흔히 쓰는 표기 대응
      if (u.includes("카이스트") || u.includes("KAIST")) return true;
      if (u.includes("유니스트") || u.includes("UNIST")) return true;
      if (u.includes("디지스트") || u.includes("DGIST")) return true;
      if (u.includes("지스트") || u.includes("GIST")) return true;
      if (u.includes("켄텍") || u.includes("KENTECH") || u.includes("한국에너지공과")) return true;
      // 포스텍 제외
      if (u.includes("포스텍") || u.includes("POSTECH")) return false;
      return false;
    }

    function renderFullReport(records) {
      plotsData = {};
      plotInitialized = {};
      currentGradeType = "all_subj";

      const univs = unique(records.map((r) => r.univ));
      const depts = unique(records.map((r) => r.dept));
      const apptypes = unique(records.map((r) => r.apptype));
      const subtypes = unique(records.map((r) => r.subtype));

      const header = `
        <div class="fixed-header">
          <div class="header-content">
            <div class="header-top">
              <div class="site-title">modified by KO</div>
            </div>
            <h2 class="university-title">수시 입시 결과 통계 프로그램 [풍무고등학교]</h2>

            <div class="controls-legend-wrapper" style="display:flex;flex-wrap:wrap;gap:12px;align-items:center;">
              <div class="grade-toggle-container" style="background:#f1eee7;border:1px solid var(--border);border-radius:12px;padding:10px;">
                <button id="btn-conv" class="grade-toggle-btn">환산등급</button>
                <button id="btn-all" class="grade-toggle-btn active">전교과100 등급</button>
              </div>

              <div class="legend-container" style="background:#f1eee7;border:1px solid var(--border);border-radius:12px;padding:10px;">
                <div class="legend-items-wrapper" style="display:flex;flex-wrap:wrap;gap:10px;align-items:center;">
                  <div class="legend-item" style="display:inline-flex;align-items:center;gap:6px;">
                    <span class="legend-marker" style="font-size:18px;color:#5f8669;">&#9679;</span><span>합격 (Y축 상단)</span>
                  </div>
                  <div class="legend-item" style="display:inline-flex;align-items:center;gap:6px;">
                    <span class="legend-marker" style="font-size:18px;color:#7cab7c;">&#9650;</span><span>충원합격 (Y축 중앙)</span>
                  </div>
                  <div class="legend-item" style="display:inline-flex;align-items:center;gap:6px;">
                    <span class="legend-marker" style="font-size:18px;color:#d07a5c;">&#10006;</span><span>불합격 (Y축 하단)</span>
                  </div>
                </div>
                <div class="axis-label" style="font-size:13px;color:var(--muted);display:flex;align-items:center;gap:6px;margin-top:6px;">
                  <span>↔</span><span id="grade-label">전교과100 등급</span> (1~9)
                </div>
              </div>
            </div>
          </div>
        </div>
      `;

      const layout = `
        <div class="layout">
          <aside class="toc-container">
            <div class="toc-header" style="font-weight:800;margin-bottom:10px;font-size:16px;">목차</div>
            <div id="toc-content"></div>
          </aside>
          <main class="main-content" id="content-area"></main>
        </div>
      `;

      reportEl.hidden = false;
      reportEl.innerHTML = header + layout;

      const contentEl = document.getElementById("content-area");
      let plotCounter = 1;

      // 출력 기준 표기
      const filterSummary = `
        <div class="dept-container" style="margin-bottom:16px;">
          <div class="print-grade-line">
            출력 기준: <span id="print-grade-text">전교과100 등급</span>
          </div>
          총 ${records.length}건 · 대학 ${univs.length} · 모집단위 ${depts.length} · 전형유형 ${apptypes.length} · 전형 ${subtypes.length}
        </div>
      `;
      contentEl.insertAdjacentHTML("beforeend", filterSummary);

      // 1) 전체 요약(현황1부 출력 대상)
      const overallBlock = buildPlotBlock(records, plotCounter, "전체 데이터", true, true, true, true);
      plotsData[plotCounter] = overallBlock.data;

      contentEl.insertAdjacentHTML("beforeend", `
        <div class="dept-container" id="overall-summary">
          <div class="dept-header" style="border-bottom:2px solid #e74c3c;">전체 데이터 요약</div>
          ${overallBlock.html}
        </div>
      `);
      plotCounter++;

      // 2) 서울+수도권+특목대 요약(별도 출력)
      const capitalRecords = records.filter(r => isCapitalByRegion(r.region) || isSpecialUniv(r.univ));
      const capitalBlock = buildPlotBlock(capitalRecords, plotCounter, "서울+수도권+특목대", true, false, true, true);
      plotsData[plotCounter] = capitalBlock.data;

      contentEl.insertAdjacentHTML("beforeend", `
        <div class="dept-container" id="capital-summary">
          <div class="dept-header" style="border-bottom:2px solid #3498db;">서울+수도권+특목대 요약</div>
          <div id="capital-spec-pass-table" style="margin-top:12px;"></div>
          <div style="margin-bottom:10px;color:var(--muted);font-size:13px;">
            * region(엑셀 F열) 기준으로 서울/경기/인천 포함 + 특수목적대학(카/유/디/지/켄텍) 포함(포스텍 제외)
          </div>
          ${capitalBlock.html}
        </div>
      `);
      plotCounter++;

      // 3) TOP20 (전체)
      contentEl.insertAdjacentHTML("beforeend", `
        <div class="dept-container" id="univ-top-global">
          <div class="dept-header">지원 상위 대학 TOP 20 합/충원/불합격</div>
          <div style="border:1px solid var(--border);border-radius:12px;padding:12px;">
            <div id="univ-top-chart" class="plot-container" style="height:420px;"></div>
          </div>
        </div>
      `);

      // 4) 대학별 섹션(전체 출력)
      univs.forEach((univ, uIdx) => {
        const dfUniv = records.filter((r) => r.univ === univ);
        let html = `
          <div class="dept-container" id="univ-${uIdx + 1}">
            <div class="dept-header">${univ}</div>
        `;

        // 전형유형별 요약
        const apptypesAll = unique(dfUniv.map((r) => r.apptype));
        if (apptypesAll.length) {
          html += `<div style="border:1px solid #e4ddcf;border-radius:12px;padding:14px;background:#fff;margin-bottom:14px;">
            <div style="font-weight:700;font-size:17px;margin-bottom:10px;">전형유형별 요약</div>`;
          apptypesAll.forEach((ap, aIdx) => {
            const subset = dfUniv.filter((r) => r.apptype === ap);
            const block = buildPlotBlock(subset, plotCounter, `${ap}`, true);
            html += `
              <div style="border:1px solid #e4ddcf;border-radius:12px;padding:14px;background:#fefefe;margin:10px 0 0 8px;">
                <div style="font-weight:700;font-size:16px;margin-bottom:8px;">${ap}</div>
                ${block.html}
              </div>
            `;
            plotsData[plotCounter] = block.data;
            plotCounter++;
          });
          html += `</div>`;
        }

        // 세부유형별 요약
        const subtypesAll = unique(dfUniv.map((r) => r.subtype));
        if (subtypesAll.length) {
          html += `<div style="border:1px solid #e4ddcf;border-radius:12px;padding:14px;background:#fff;margin-bottom:14px;">
            <div style="font-weight:700;font-size:17px;margin-bottom:10px;">세부유형별 요약</div>`;
          subtypesAll.forEach((st, sIdx) => {
            const subset = dfUniv.filter((r) => r.subtype === st);
            const block = buildPlotBlock(subset, plotCounter, `${st}`, true);
            html += `
              <div style="border:1px solid #e4ddcf;border-radius:12px;padding:14px;background:#fefefe;margin:10px 0 0 8px;">
                <div style="font-weight:700;font-size:16px;margin-bottom:8px;">${st}</div>
                ${block.html}
              </div>
            `;
            plotsData[plotCounter] = block.data;
            plotCounter++;
          });
          html += `</div>`;
        }

        // 모집단위 상세
        const univDepts = unique(dfUniv.map((r) => r.dept));
        univDepts.forEach((dept, dIdx) => {
          const dfDept = dfUniv.filter((r) => r.dept === dept);
          html += `
            <div style="border:1px solid #e4ddcf;border-radius:12px;padding:14px;background:#fff;margin-bottom:14px;">
              <div style="font-weight:700;font-size:16px;margin-bottom:10px;color:#34495e;">${dIdx + 1}) ${dept}</div>
          `;

          const deptSubtypes = unique(dfDept.map((r) => r.subtype));
          deptSubtypes.forEach((st, sIdx) => {
            const subset = dfDept.filter((r) => r.subtype === st);
            if (!subset.length) return;
            const block = buildPlotBlock(subset, plotCounter, `${st}`, true);
            html += `
              <div style="border:1px solid #e4ddcf;border-radius:12px;padding:14px;background:#fefefe;margin:10px 0 0 10px;">
                <div style="font-weight:700;font-size:15px;margin-bottom:8px;">${sIdx + 1}) ${st}</div>
                ${block.html}
              </div>
            `;
            plotsData[plotCounter] = block.data;
            plotCounter++;
          });

          html += `</div>`;
        });

        html += `</div>`;
        contentEl.insertAdjacentHTML("beforeend", html);
      });

      bindGradeToggle();
      initPlots();
      buildTOC();
      syncStickyTop();
      renderCapitalAndSpecPassTable(records, { includeWaitlist: true });

    }

    function syncStickyTop() {
      const header = document.querySelector(".fixed-header");
      if (!header) return;
      const h = header.offsetHeight || 0;
      const top = Math.max(160, h + 16);
      document.documentElement.style.setProperty("--stickyTop", top + "px");
    }
    window.addEventListener("resize", syncStickyTop);
  </script>

  <script>
    function buildPlotBlock(dataArr, plotId, title, showStats = true, includeHist = false, includeBands = false, includeApptype = false) {
      const convStats = computeStats(dataArr, "conv_grade");
      const allStats  = computeStats(dataArr, "all_subj_grade");
      const convDetail = computeAdditionalStats(dataArr, "conv_grade");
      const allDetail  = computeAdditionalStats(dataArr, "all_subj_grade");
      const plotData = createPlotData(dataArr);

      const statsHtmlConv = showStats ? createStatsHtml(convStats) : "";
      const statsHtmlAll  = showStats ? createStatsHtml(allStats) : "";
      const detailConv = showStats ? createDetailTable(convDetail, "환산등급") : "";
      const detailAll  = showStats ? createDetailTable(allDetail, "전교과등급") : "";

      let extraHtml = "";

      if (includeHist) {
        extraHtml += `
          <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:12px;margin-top:10px;">
            <div style="border:1px solid var(--border);border-radius:12px;padding:12px;">
              <h3 style="margin:0 0 8px;font-size:15px;">전교과등급 히스토그램</h3>
              <div id="hist-all-${plotId}" class="plot-container" style="height:260px;"></div>
            </div>
            <div style="border:1px solid var(--border);border-radius:12px;padding:12px;">
              <h3 style="margin:0 0 8px;font-size:15px;">환산등급 히스토그램</h3>
              <div id="hist-conv-${plotId}" class="plot-container" style="height:260px;"></div>
            </div>
          </div>
        `;
      }

      if (includeBands) {
        extraHtml += `
          <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:12px;margin-top:10px;">
            <div style="border:1px solid var(--border);border-radius:12px;padding:12px;">
              <h3 style="margin:0 0 8px;font-size:15px;">전교과 등급대별 합격/불합격</h3>
              <div id="band-bar-${plotId}" class="plot-container" style="height:280px;"></div>
            </div>
            <div style="border:1px solid var(--border);border-radius:12px;padding:12px;">
              <h3 style="margin:0 0 8px;font-size:15px;">등급대별 통계</h3>
              <div id="band-table-${plotId}"></div>
            </div>
          </div>
        `;
      }

      if (includeApptype) {
        extraHtml += `
          <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:12px;margin-top:10px;">
            <div style="border:1px solid var(--border);border-radius:12px;padding:12px;">
              <h3 style="margin:0 0 8px;font-size:15px;">전형유형별 합/불 현황</h3>
              <div id="apptype-bar-${plotId}" class="plot-container" style="height:280px;"></div>
            </div>
            <div style="border:1px solid var(--border);border-radius:12px;padding:12px;">
              <h3 style="margin:0 0 8px;font-size:15px;">전형유형별 통계</h3>
              <div id="apptype-table-${plotId}"></div>
            </div>
          </div>
        `;
      }

      const html = `
        <div style="display:flex;flex-direction:column;gap:10px;">
          <div id="conv-stats-${plotId}" style="display:none;flex-wrap:wrap;gap:8px;">${statsHtmlConv}</div>
          <div id="all-stats-${plotId}" style="display:flex;flex-wrap:wrap;gap:8px;">${statsHtmlAll}</div>

          <div class="plot-container" id="plot-${plotId}" style="width:100%;height:220px;"></div>

          <div id="conv-detail-${plotId}" style="display:none;">${detailConv}</div>
          <div id="all-detail-${plotId}" style="display:block;">${detailAll}</div>
          ${extraHtml}
        </div>
      `;

      return { html, data: plotData };
    }

    function createPlotData(dataArr) {
      const studentLabel = (r) => {
        const name = r.student_name || "";
        const g = r.grade || "";
        const c = r.class_no || "";
        const n = r.student_no || "";
        const tail = [g, c, n].filter(Boolean).join("-");
        if (!name && !tail) return "";
        return tail ? `학생: ${name} (${tail})` : `학생: ${name}`;
      };

      const convTraces = RESULT_ORDER.map((res) => {
        const rows = dataArr.filter((r) => r.result === res && r.conv_grade !== null);
        return {
          x: rows.map((r) => r.conv_grade),
          y: rows.map(() => Y_POS[res] ?? 0),
          type: "scatter",
          mode: "markers",
          name: res,
          marker: {
            color: COLOR_MAP[res].fill,
            line: { color: COLOR_MAP[res].border, width: 1.5 },
            symbol: SYMBOL_MAP[res] || "circle",
            size: 12,
          },
          customdata: rows.map((r) => [r.dept, r.subtype, r.univ, r.region, studentLabel(r)]),
          hovertemplate:
            "환산등급: %{x}<br>대학: %{customdata[2]}<br>지역: %{customdata[3]}<br>모집단위: %{customdata[0]}<br>전형: %{customdata[1]}<br>%{customdata[4]}<extra></extra>",
          showlegend: false,
        };
      });

      const allTraces = RESULT_ORDER.map((res) => {
        const rows = dataArr.filter((r) => r.result === res && r.all_subj_grade !== null);
        return {
          x: rows.map((r) => r.all_subj_grade),
          y: rows.map(() => Y_POS[res] ?? 0),
          type: "scatter",
          mode: "markers",
          name: res,
          marker: {
            color: COLOR_MAP[res].fill,
            line: { color: COLOR_MAP[res].border, width: 1.5 },
            symbol: SYMBOL_MAP[res] || "circle",
            size: 12,
          },
          customdata: rows.map((r) => [r.dept, r.subtype, r.univ, r.region, studentLabel(r)]),
          hovertemplate:
            "전교과등급: %{x}<br>대학: %{customdata[2]}<br>지역: %{customdata[3]}<br>모집단위: %{customdata[0]}<br>전형: %{customdata[1]}<br>%{customdata[4]}<extra></extra>",
          showlegend: false,
        };
      });

      return { convTraces, allTraces };
    }

    function createStatsHtml(stats) {
      const items = [];
      items.push(`<div style="padding:7px 11px;border-radius:8px;background:#e4e0d7;border:1px solid #d6cebf;font-size:13px;font-weight:800;">총 ${stats.total_count}건</div>`);

      items.push(`<div style="padding:7px 11px;border-radius:8px;background:#eef0eb;border:1px solid #d6cebf;font-size:13px;border-left:4px solid var(--primary);">
        합격(일반): ${stats.pass_count}건 (${stats.pass_rate})
      </div>`);

      items.push(`<div style="padding:7px 11px;border-radius:8px;background:#eef0eb;border:1px solid #d6cebf;font-size:13px;border-left:4px solid #7cab7c;">
        충원합격: ${stats.waitlist_count}건 (${stats.waitlist_rate})
      </div>`);

      const failRate = stats.total_count ? ((stats.fail_count / stats.total_count) * 100).toFixed(1) + "%" : "0.0%";
      items.push(`<div style="padding:7px 11px;border-radius:8px;background:#eef0eb;border:1px solid #d6cebf;font-size:13px;border-left:4px solid #d26c5b;">
        불합격: ${stats.fail_count}건 (${failRate})
      </div>`);

      items.push(`<div style="padding:7px 11px;border-radius:8px;background:#f7f7f2;border:1px solid #d6cebf;font-size:13px;">
        합격(충원포함): ${stats.all_pass_count}건 (${stats.all_pass_rate || "0%"})
      </div>`);

      return items.join("");
    }

    function createDetailTable(detail, title) {
      const rows = RESULT_ORDER.map((res) => {
        const d = detail[res] || {};
        if (!d.count) return `<tr><td>${res}</td><td colspan="6">데이터 없음</td></tr>`;
        return `<tr>
          <td>${res}</td>
          <td>${d.count}</td>
          <td>${fmt(d.mean)}</td>
          <td>${fmt(d.std)}</td>
          <td>${fmt(d.min)} ~ ${fmt(d.max)}</td>
          <td>${fmt(d.median)}</td>
          <td>${fmtRange(d.q1, d.q3)}</td>
        </tr>`;
      }).join("");

      return `
        <div style="border:1px solid var(--border);border-radius:12px;padding:12px;margin-top:10px;">
          <h3 style="margin:0 0 8px;font-size:15px;">${title} 상세 통계</h3>
          <table class="stats-table">
            <thead>
              <tr>
                <th>결과</th>
                <th>건수</th>
                <th>평균</th>
                <th>표준편차</th>
                <th>범위</th>
                <th>중앙값</th>
                <th>1Q-3Q</th>
              </tr>
            </thead>
            <tbody>${rows}</tbody>
          </table>
        </div>
      `;
    }

    function computeStats(dataArr, gradeKey) {
      const total = dataArr.length;
      const counts = RESULT_ORDER.reduce((acc, r) => {
        acc[r] = dataArr.filter((d) => d.result === r).length;
        return acc;
      }, {});

      const passData = dataArr
        .filter((d) => d.result === "합격" || d.result === "충원합격")
        .map((d) => d[gradeKey])
        .filter((v) => v !== null);

      const stats = {
        total_count: total,
        pass_count: counts["합격"] || 0,
        waitlist_count: counts["충원합격"] || 0,
        fail_count: counts["불합격"] || 0,
      };

      stats.all_pass_count = stats.pass_count + stats.waitlist_count;
      stats.pass_rate = total ? ((stats.pass_count / total) * 100).toFixed(1) + "%" : "0.0%";
      stats.waitlist_rate = total ? ((stats.waitlist_count / total) * 100).toFixed(1) + "%" : "0.0%";
      stats.all_pass_rate = total ? ((stats.all_pass_count / total) * 100).toFixed(1) + "%" : "0.0%";

      if (passData.length) {
        stats.all_pass_min = Math.min(...passData);
        stats.all_pass_max = Math.max(...passData);
        stats.all_pass_mean = mean(passData);
      }
      return stats;
    }

    function computeAdditionalStats(dataArr, key) {
      const out = {};
      RESULT_ORDER.forEach((res) => {
        const arr = dataArr.filter((d) => d.result === res).map((d) => d[key]).filter((v) => v !== null);
        if (!arr.length) { out[res] = { count: 0 }; return; }
        out[res] = {
          count: arr.length,
          mean: mean(arr),
          std: stddev(arr),
          min: Math.min(...arr),
          max: Math.max(...arr),
          median: percentile(arr, 50),
          q1: percentile(arr, 25),
          q3: percentile(arr, 75),
        };
      });
      return out;
    }

    function mean(arr) { return arr.reduce((a, b) => a + b, 0) / arr.length; }
    function stddev(arr) {
      if (arr.length < 2) return 0;
      const m = mean(arr);
      return Math.sqrt(arr.reduce((s, v) => s + Math.pow(v - m, 2), 0) / (arr.length - 1));
    }
    function percentile(arr, p) {
      if (!arr.length) return 0;
      const s = [...arr].sort((a, b) => a - b);
      const rank = (p / 100) * (s.length - 1);
      const l = Math.floor(rank);
      const h = Math.ceil(rank);
      if (l === h) return s[l];
      const w = rank - l;
      return s[l] * (1 - w) + s[h] * w;
    }
    function fmt(v) { return v === undefined || v === null || Number.isNaN(v) ? "-" : Number(v).toFixed(2); }
    function fmtRange(a, b) { if ([a, b].some((x) => x === undefined || x === null || Number.isNaN(x))) return "-"; return `${Number(a).toFixed(2)} ~ ${Number(b).toFixed(2)}`; }

    function createLayout() {
      return {
        height: 220,
        autosize: true,
        margin: { t: 12, b: 45, l: 55, r: 25 },
        xaxis: {
          range: [0.5, 9.5],
          tickmode: "array",
          tickvals: [1,2,3,4,5,6,7,8,9],
          ticktext: ["1","2","3","4","5","6","7","8","9"],
          title: "등급"
        },
        yaxis: {
          range: [-0.05, 0.05],
          tickmode: "array",
          tickvals: [0.01, 0.0, -0.03],
          ticktext: ["", "", ""],
          showgrid: false,
          zeroline: false
        },
        showlegend: false,
        plot_bgcolor: "#fff",
        paper_bgcolor: "#fff",
      };
    }

    function initPlots() {
      document.querySelectorAll(".plot-container[id^='plot-']").forEach((div) => {
        const id = div.id.split("-")[1];
        const data = plotsData[id];
        if (!data) return;
        const traces = currentGradeType === "conv" ? data.convTraces : data.allTraces;
        Plotly.newPlot(div, traces, createLayout(), { displayModeBar: false, responsive: true });
        plotInitialized[id] = true;
      });

      Object.keys(plotsData).forEach((pid) => {
        if (document.getElementById(`hist-all-${pid}`)) renderHist(lastRecords, "all_subj_grade", `hist-all-${pid}`, "전교과등급");
        if (document.getElementById(`hist-conv-${pid}`)) renderHist(lastRecords, "conv_grade", `hist-conv-${pid}`, "환산등급");
        if (document.getElementById(`band-bar-${pid}`)) renderGradeBands(lastRecords, "all_subj_grade", pid);
        if (document.getElementById(`apptype-bar-${pid}`)) renderApptypeStats(lastRecords, pid);
      });

      renderUnivTop(lastRecords);
    }
//내가 넣은 코드
// ✅ 대학명 보정(너가 준 규칙 반영)
function normalizeUnivName(name) {
  const raw = (name || "").trim();
  if (!raw) return "";

  const MAP = {
    "국립한국해양대학교(부산)": "한국해양대",
    "한양대학교(ERICA)": "한양대(에)",
    "광주여자대학교(광주)": "광주여대",
    "중부대학교(고양) - 고양캠퍼스": "중부대",
    "중부대학교(금산) - 충청캠퍼스": "중부대",
    "동국대학교(WISE)": "동국대(W)",
    "중앙대학교(다빈치)": "중앙대(다)",
    "건국대학교(글로컬)": "건국대(글)",
    "상명대학교(천안)": "상명대(천)",
    "한국기술교육대학교(천안)": "한국기술교대",
    "한국항공대학교(고양)": "한국항공대",
    "홍익대학교(세종)": "홍익대(세)"
  };

  if (MAP[raw]) return MAP[raw];

  // ✅ "서울지역과 동일한 명칭의 지방캠퍼스" 규칙:
  // 괄호가 있으면 괄호 안 첫 글자만 표기 (예: 고려대학교(세종) -> 고려대(세))
  // 단, 이미 (에)/(W)/(다)/(글)/(천)/(세) 등으로 보정된 케이스는 위 MAP에서 처리됨.
  const m = raw.match(/^(.*)\((.+)\)$/);
  if (m) {
    const base = m[1].trim();
    const inside = (m[2] || "").trim();
    const firstChar = inside ? inside[0] : "";
    // base가 너무 길면 흔히 쓰는 약칭으로 줄이는 건 학교마다 달라서 여기서는 그대로 둠
    return firstChar ? `${base.replace(/대학교$/, "대")}(${firstChar})` : base.replace(/대학교$/, "대");
  }

  return raw.replace(/대학교$/, "대");
}

// ✅ 수도권/특목대 판정 + 표 렌더링
function renderCapitalAndSpecPassTable(records, options = {}) {
  const host = document.getElementById("capital-spec-pass-table");
  if (!host) return;

  const includeWaitlist = !!options.includeWaitlist; // false면 '합격'만
  const topN = options.topN || 0; // 0이면 전체, 20이면 상위20만

  // 1) 수도권(region 최우선)
  const isCapitalByRegion = (region) => ["서울", "경기", "인천"].includes((region || "").trim());

  // 2) 특목대(포스텍 제외, 켄텍 포함)
  //    ⚠️ 여기 이름은 normalizeUnivName() 기준으로 맞추는 게 안전함
  const SPECIAL_UNIVS = new Set([
    "KAIST", "카이스트",
    "UNIST", "유니스트",
    "DGIST", "디지스트",
    "GIST", "지스트",
    "한국에너지공과대학교", "켄텍", "KENTECH"
  ]);

  const isSpecial = (univNormalized) => SPECIAL_UNIVS.has(univNormalized);

  // ✅ 대상 추출: 수도권 + 특목대
  const picked = records.filter(r => {
    const uNorm = normalizeUnivName(r.univ);
    const capital = isCapitalByRegion(r.region);
    const spec = isSpecial(uNorm);
    return capital || spec;
  });

  // ✅ 합격 집계 (옵션에 따라 충원 포함 가능)
  const isPass = (r) => {
    if (includeWaitlist) return (r.result === "합격" || r.result === "충원합격");
    return r.result === "합격";
  };

  const map = new Map(); // univ -> count
  picked.filter(isPass).forEach(r => {
    const uNorm = normalizeUnivName(r.univ) || "미상";
    map.set(uNorm, (map.get(uNorm) || 0) + 1);
  });

  let rows = Array.from(map.entries())
    .map(([univ, cnt]) => ({ univ, cnt }))
    .sort((a, b) => b.cnt - a.cnt || a.univ.localeCompare(b.univ, "ko"));

  if (topN > 0) rows = rows.slice(0, topN);

  if (!rows.length) {
    host.innerHTML = `<div class="empty">수도권+특목대 ‘합격’ 데이터가 없습니다.</div>`;
    return;
  }

  host.innerHTML = `
    <div style="border:1px solid var(--border);border-radius:12px;padding:12px;background:#fff;">
      <div style="display:flex;justify-content:space-between;gap:10px;align-items:flex-end;margin-bottom:10px;flex-wrap:wrap;">
        <div style="font-weight:800;font-size:16px;">수도권+특목대 대학별 합격 인원</div>
        <div style="color:var(--muted);font-size:12px;">
          기준: region=서울/경기/인천 + 특목대(포스텍 제외, 켄텍 포함) · 결과=${includeWaitlist ? "합격+충원합격" : "합격"}
        </div>
      </div>

      <table class="stats-table">
        <thead>
          <tr>
            <th style="width:56px;">순위</th>
            <th>대학</th>
            <th style="width:120px;">합격 인원</th>
          </tr>
        </thead>
        <tbody>
          ${rows.map((r, i) => `
            <tr>
              <td>${i + 1}</td>
              <td style="text-align:left;padding-left:10px;">${r.univ}</td>
              <td style="font-weight:800;">${r.cnt}</td>
            </tr>
          `).join("")}
        </tbody>
      </table>
    </div>
  `;
}


//여기까지    
    function updateAllPlots() {
      document.querySelectorAll(".plot-container[id^='plot-']").forEach((div) => {
        const id = div.id.split("-")[1];
        const data = plotsData[id];
        if (!data || !plotInitialized[id]) return;
        const traces = currentGradeType === "conv" ? data.convTraces : data.allTraces;
        Plotly.react(div, traces, createLayout(), { displayModeBar: false, responsive: true });
      });
    }

    function bindGradeToggle() {
      const btnConv = document.getElementById("btn-conv");
      const btnAll  = document.getElementById("btn-all");
      btnConv.onclick = () => switchGrade("conv");
      btnAll.onclick  = () => switchGrade("all_subj");
    }

    function switchGrade(type) {
      if (currentGradeType === type) return;
      currentGradeType = type;

      document.getElementById("btn-conv").classList.toggle("active", type === "conv");
      document.getElementById("btn-all").classList.toggle("active", type === "all_subj");

      document.getElementById("grade-label").textContent = type === "conv" ? "환산등급" : "전교과100 등급";
      const pg = document.getElementById("print-grade-text");
      if (pg) pg.textContent = type === "conv" ? "환산등급" : "전교과100 등급";

      document.querySelectorAll("[id^='conv-stats-']").forEach((el) => el.style.display = type === "conv" ? "flex" : "none");
      document.querySelectorAll("[id^='all-stats-']").forEach((el)  => el.style.display = type === "all_subj" ? "flex" : "none");
      document.querySelectorAll("[id^='conv-detail-']").forEach((el)=> el.style.display = type === "conv" ? "block" : "none");
      document.querySelectorAll("[id^='all-detail-']").forEach((el) => el.style.display = type === "all_subj" ? "block" : "none");

      updateAllPlots();
    }

    // ✅ 목차: 큰 섹션만 잡아도 충분히 안정적
    function buildTOC() {
      const toc = document.getElementById("toc-content");
      const items = [];

      const pushItem = (id, label) => {
        if (document.getElementById(id)) items.push({id,label});
      };

      pushItem("overall-summary", "전체 데이터 요약");
      pushItem("capital-summary", "서울+수도권+특목대 요약");
      pushItem("univ-top-global", "지원 TOP20");

      document.querySelectorAll("[id^='univ-']").forEach((el) => {
        const header = el.querySelector(".dept-header");
        if (!header) return;
        items.push({ id: el.id, label: header.textContent });
      });

      toc.innerHTML = items.map(it =>
        `<div style="font-weight:700;cursor:pointer;padding:6px;border-radius:8px;color:var(--primary-dark);" onclick="scrollToElement('${it.id}')">${it.label}</div>`
      ).join("");
    }

    function scrollToElement(id) {
      const el = document.getElementById(id);
      if (!el) return;
      const headerHeight = document.querySelector(".fixed-header")?.offsetHeight || 0;
      const top = el.getBoundingClientRect().top + window.pageYOffset - headerHeight - 10;
      window.scrollTo({ top, behavior: "smooth" });
    }
    window.scrollToElement = scrollToElement;

    function makeHistogramSeries(records, key) {
      const passArr = records.filter((r) => r.result === "합격" || r.result === "충원합격").map((r) => r[key]).filter((v) => v !== null);
      const failArr = records.filter((r) => r.result === "불합격").map((r) => r[key]).filter((v) => v !== null);
      const edges = [];
      for (let v = BINS.start; v < BINS.end; v += BINS.size) edges.push(Number(v.toFixed(4)));
      edges.push(BINS.end);
      const bins = edges.length - 1;
      const passCounts = new Array(bins).fill(0);
      const failCounts = new Array(bins).fill(0);
      const center = [];
      for (let i = 0; i < bins; i++) center.push((edges[i] + edges[i + 1]) / 2);

      const fillCounts = (arr, target) => {
        arr.forEach((v) => {
          if (v < BINS.start || v > BINS.end) return;
          const idx = Math.min(Math.floor((v - BINS.start) / BINS.size), bins - 1);
          target[idx] += 1;
        });
      };
      fillCounts(passArr, passCounts);
      fillCounts(failArr, failCounts);
      return { center, passCounts, failCounts };
    }

    function makeGradeBandStats(records, key) {
      const bands = [
        { label: "1등급대", from: 1, to: 1.999 },
        { label: "2등급대", from: 2, to: 2.999 },
        { label: "3등급대", from: 3, to: 3.999 },
        { label: "4등급대", from: 4, to: 4.999 },
        { label: "5등급대", from: 5, to: 5.999 },
        { label: "6등급대", from: 6, to: 6.999 },
        { label: "7등급대", from: 7, to: 7.999 },
        { label: "8등급대", from: 8, to: 8.999 },
        { label: "9등급대", from: 9, to: 9.999 },
      ];
      return bands.map((b) => {
        const inBand = records.filter((r) => r[key] !== null && r[key] >= b.from && r[key] <= b.to);
        const pass = inBand.filter((r) => r.result === "합격" || r.result === "충원합격").length;
        const fail = inBand.filter((r) => r.result === "불합격").length;
        const total = pass + fail;
        return { label: b.label, pass, fail, total, passRate: total ? (pass / total) * 100 : 0 };
      });
    }

    function renderGradeBands(records, key, targetPlotId) {
      const stats = makeGradeBandStats(records, key);
      const labels = stats.map((s) => s.label);
      const passCounts = stats.map((s) => s.pass);
      const failCounts = stats.map((s) => s.fail);
      const hasData = stats.some((s) => s.total > 0);

      const barEl = document.getElementById(`band-bar-${targetPlotId}`);
      const tableEl = document.getElementById(`band-table-${targetPlotId}`);

      if (barEl) {
        if (!hasData) {
          barEl.innerHTML = '<div class="empty">데이터 없음</div>';
        } else {
          Plotly.newPlot(barEl, [
            { x: labels, y: passCounts, type: "bar", name: "합격(충원포함)", marker: { color: COLOR_MAP["합격"].border } },
            { x: labels, y: failCounts, type: "bar", name: "불합격", marker: { color: COLOR_MAP["불합격"].border } },
          ], {
            height: 280,
            barmode: "stack",
            margin: { t: 20, b: 40, l: 45, r: 20 },
            yaxis: { title: "인원" },
          }, { displayModeBar: false, responsive: true });
        }
      }

      if (tableEl) {
        const rows = stats.map((s) => {
          if (!s.total) return `<tr><td>${s.label}</td><td colspan="4">데이터 없음</td></tr>`;
          return `<tr>
            <td>${s.label}</td>
            <td>${s.pass}</td>
            <td>${s.fail}</td>
            <td>${s.total}</td>
            <td>${s.passRate.toFixed(1)}%</td>
          </tr>`;
        }).join("");

        tableEl.innerHTML = `
          <table class="stats-table">
            <thead><tr><th>등급대</th><th>합격</th><th>불합격</th><th>총원</th><th>합격률</th></tr></thead>
            <tbody>${rows}</tbody>
          </table>
        `;
      }
    }

    function makeApptypeStats(records) {
      const groups = {};
      records.forEach((r) => {
        const key = r.apptype || "미상";
        if (!groups[key]) groups[key] = { total: 0, pass: 0, wait: 0, fail: 0 };
        groups[key].total += 1;
        if (r.result === "합격") groups[key].pass += 1;
        else if (r.result === "충원합격") groups[key].wait += 1;
        else if (r.result === "불합격") groups[key].fail += 1;
      });
      return Object.entries(groups).map(([apptype, g]) => {
        const total = g.total || 1;
        return {
          apptype, total: g.total, pass: g.pass, wait: g.wait, fail: g.fail,
          passRate: (g.pass / total) * 100,
          waitRate: (g.wait / total) * 100,
          failRate: (g.fail / total) * 100,
        };
      }).sort((a, b) => b.total - a.total);
    }

    function renderApptypeStats(records, plotId) {
      const stats = makeApptypeStats(records);
      const labels = stats.map((s) => s.apptype);
      const passCounts = stats.map((s) => s.pass);
      const waitCounts = stats.map((s) => s.wait);
      const failCounts = stats.map((s) => s.fail);
      const hasData = stats.some((s) => s.total > 0);

      const barEl = document.getElementById(`apptype-bar-${plotId}`);
      const tableEl = document.getElementById(`apptype-table-${plotId}`);

      if (barEl) {
        if (!hasData) {
          barEl.innerHTML = '<div class="empty">데이터 없음</div>';
        } else {
          Plotly.newPlot(barEl, [
            { y: labels, x: passCounts, type: "bar", name: "합격", orientation: "h", marker: { color: COLOR_MAP["합격"].border } },
            { y: labels, x: waitCounts, type: "bar", name: "충원합격", orientation: "h", marker: { color: COLOR_MAP["충원합격"].border } },
            { y: labels, x: failCounts, type: "bar", name: "불합격", orientation: "h", marker: { color: COLOR_MAP["불합격"].border } },
          ], {
            height: Math.max(240, 26 * labels.length + 80),
            barmode: "stack",
            margin: { t: 20, b: 40, l: 120, r: 20 },
            xaxis: { title: "인원" },
          }, { displayModeBar: false, responsive: true });
        }
      }

      if (tableEl) {
        const rows = stats.map((s) => {
          if (!s.total) return `<tr><td>${s.apptype}</td><td colspan="7">데이터 없음</td></tr>`;
          return `<tr>
            <td>${s.apptype}</td>
            <td>${s.total}</td>
            <td>${s.pass}</td>
            <td>${s.wait}</td>
            <td>${s.fail}</td>
            <td>${s.passRate.toFixed(1)}%</td>
            <td>${s.waitRate.toFixed(1)}%</td>
            <td>${s.failRate.toFixed(1)}%</td>
          </tr>`;
        }).join("");

        tableEl.innerHTML = `
          <table class="stats-table">
            <thead><tr><th>전형유형</th><th>총원</th><th>합격</th><th>충원</th><th>불합격</th><th>합격률</th><th>충원률</th><th>불합격률</th></tr></thead>
            <tbody>${rows}</tbody>
          </table>
        `;
      }
    }

    function renderUnivTop(records) {
      const univTopEl = document.getElementById("univ-top-chart");
      if (!univTopEl) return;

      const grouped = {};
      records.forEach((r) => {
        const key = r.univ || "미상";
        if (!grouped[key]) grouped[key] = { pass: 0, wait: 0, fail: 0, total: 0 };
        grouped[key].total += 1;
        if (r.result === "합격") grouped[key].pass += 1;
        else if (r.result === "충원합격") grouped[key].wait += 1;
        else if (r.result === "불합격") grouped[key].fail += 1;
      });

      const sorted = Object.entries(grouped)
        .map(([univ, g]) => ({ univ, ...g }))
        .filter((x) => x.total > 0)
        .sort((a, b) => b.total - a.total)
        .slice(0, 20);

      const labelsTop = sorted.map((s) => s.univ);
      const passTop = sorted.map((s) => s.pass);
      const waitTop = sorted.map((s) => s.wait);
      const failTop = sorted.map((s) => s.fail);

      if (!sorted.length) {
        univTopEl.innerHTML = '<div class="empty">데이터 없음</div>';
      } else {
        const dynamicHeight = Math.max(360, 26 * labelsTop.length + 110);
        univTopEl.style.height = dynamicHeight + "px";
        Plotly.newPlot(univTopEl, [
          { y: labelsTop, x: passTop, type: "bar", name: "합격", orientation: "h", marker: { color: COLOR_MAP["합격"].border } },
          { y: labelsTop, x: waitTop, type: "bar", name: "충원합격", orientation: "h", marker: { color: COLOR_MAP["충원합격"].border } },
          { y: labelsTop, x: failTop, type: "bar", name: "불합격", orientation: "h", marker: { color: COLOR_MAP["불합격"].border } },
        ], {
          height: dynamicHeight,
          barmode: "stack",
          margin: { t: 24, b: 40, l: 150, r: 24 },
          xaxis: { title: "인원" },
        }, { displayModeBar: false, responsive: true });
      }
    }

    function renderHist(records, key, targetId, title) {
      const el = document.getElementById(targetId);
      if (!el) return;

      const { center, passCounts, failCounts } = makeHistogramSeries(records, key);
      const hasData = passCounts.some((c) => c > 0) || failCounts.some((c) => c > 0);

      if (!hasData) { el.innerHTML = '<div class="empty">데이터 없음</div>'; return; }

      const maxVal = Math.max(...passCounts, ...failCounts, 0);
      const traces = [
        {
          x: center, y: passCounts, type: "bar",
          name: "합격(충원포함)", marker: { color: COLOR_MAP["합격"].border },
          width: BINS.size * 0.9,
        },
        {
          x: center, y: failCounts.map((v) => -v), type: "bar",
          name: "불합격", marker: { color: COLOR_MAP["불합격"].border },
          width: BINS.size * 0.9,
        },
      ];
      Plotly.newPlot(el, traces, {
        height: 260,
        barmode: "relative",
        bargap: 0.02,
        margin: { t: 20, b: 45, l: 50, r: 20 },
        xaxis: { title: "등급", range: [BINS.start, BINS.end] },
        yaxis: { title: "인원(+합격 / -불합격)", zeroline: true, range: [-maxVal * 1.2, maxVal * 1.2] },
      }, { displayModeBar: false, responsive: true });
    }
    // ===== 공유용 JSON 내보내기 =====
let shareExportReady = false;

function enableJsonExport() {
  const btn = document.getElementById("json-btn");
  if (!btn) return;
  btn.disabled = false;
  shareExportReady = true;
}

document.addEventListener("click", (e) => {
  if (e.target && e.target.id === "json-btn") {
    exportShareJson();
  }
});

function exportShareJson() {
  if (!shareExportReady || !lastRecords || !lastRecords.length) {
    alert("먼저 보고서를 생성해주세요!");
    return;
  }

  // ✅ 여기서 lastRecords를 “개인정보 없는 요약”으로 바꿔서 내보냅니다.
  // 수도권/특목대 합격인원(대학별)만 포함 (최소 공유 단위)
  const { metroPassByUniv, spUnivPassByUniv } = buildPassTablesForShare(lastRecords);

  const payload = {
    generatedAt: new Date().toISOString(),
    tables: {
      metroPassByUniv,
      spUnivPassByUniv
    }
  };

  downloadJson(payload, "share.json");
}

function downloadJson(obj, fileName) {
  const text = JSON.stringify(obj, null, 2);
  const blob = new Blob([text], { type: "application/json;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = fileName;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

/**
 * ✅ “엑셀 region 최우선” 원칙을 존중:
 * - 수도권 판정은 region 값이 있으면 region으로, 없으면 대학명 보정 규칙으로.
 * - 특목대는 별도 집계(수도권 표에도 같이 나오게 하고 싶으면 합칠 수도 있음)
 *
 * 아래 구현은 “region 기반 + 보정된 대학명 기반”을 같이 씁니다.
 */
function buildPassTablesForShare(records) {
  // 합격(충원 포함)만
  const passRows = records.filter(r => r.result === "합격" || r.result === "충원합격");

  // 1) 대학명 보정(사용자 룰 반영: () 첫글자만 등)
  //    ※ 이 함수는 “출력/공유용”에서만 쓰라고 하셨으니 여기서만 적용
  const normalizeUniv = (name) => {
    let s = String(name || "").trim();
    if (!s) return s;

    // 사용자가 준 대표 치환
    const map = new Map([
      ["국립한국해양대학교(부산)", "한국해양대"],
      ["한양대학교(ERICA)", "한양대(에)"],
      ["광주여자대학교(광주)", "광주여대"],
      ["중부대학교(고양) - 고양캠퍼스", "중부대"],
      ["중부대학교(금산) - 충청캠퍼스", "중부대"],
      ["동국대학교(WISE)", "동국대(W)"],
      ["중앙대학교(다빈치)", "중앙대(다)"],
      ["건국대학교(글로컬)", "건국대(글)"],
      ["상명대학교(천안)", "상명대(천)"],
      ["한국기술교육대학교(천안)", "한국기술교대"],
      ["한국항공대학교(고양)", "한국항공대"],
      ["홍익대학교(세종)", "홍익대(세)"],
    ]);
    if (map.has(s)) return map.get(s);

    // “서울지역과 동일한 명칭으로 운영하는 지방대 → () 첫글자만”
    // 예: 고려대학교(세종) -> 고려대(세)
    //     중앙대학교(다빈치) 같은 케이스도 동일 처리 가능
    // 1) 괄호형: (세종)
    const m1 = s.match(/^(.+?)\((.+?)\)\s*$/);
    if (m1) {
      const base = m1[1].trim();
      const campus = m1[2].trim();
      const first = campus ? campus[0] : "";
      return first ? `${shortenBase(base)}(${first})` : shortenBase(base);
    }

    // 2) 하이픈형: " - 세종캠퍼스" 같은 표현 (이미 map에 일부 있지만 일반화)
    //    ex) "홍익대학교 - 세종캠퍼스" -> 홍익대(세)
    const m2 = s.match(/^(.+?)\s*-\s*(.+?)캠퍼스\s*$/);
    if (m2) {
      const base = m2[1].trim();
      const campus = m2[2].trim();
      const first = campus ? campus[0] : "";
      return first ? `${shortenBase(base)}(${first})` : shortenBase(base);
    }

    // 기본 축약: "대학교" 등 제거는 원하면 더 강화 가능
    return shortenBase(s);
  };

  function shortenBase(base) {
    // 너무 과격하게 줄이면 동명이교 위험 → “대학교”→“대” 정도만
    return base.replace(/대학교$/,"대").replace(/국립$/,"");
  }

  // 2) 수도권 판정: region 우선
  const isMetroByRegion = (region) => {
    const r = String(region||"").trim();
    if (!r) return null; // region 없으면 미판정
    // 수도권: 서울/경기/인천
    return (r.includes("서울") || r.includes("경기") || r.includes("인천"));
  };

  // 3) 특목대 목록 (포스텍 제외, 켄텍 포함)
  //   - 실제 데이터 “대학명”이 어떤 문자열인지에 따라 normalize 후 비교합니다.
  const SP_SET = new Set([
    "KAIST", "카이스트", "UNIST", "유니스트", "DGIST", "디지스트", "GIST", "지스트",
    "KENTECH", "켄텍", "한국에너지공대", "한국에너지공과대학교"
  ].map(x=>normalizeUniv(x)));

  // 4) 집계 함수
  const countByUniv = (rows) => {
    const m = new Map();
    rows.forEach(r=>{
      const u = normalizeUniv(r.univ);
      if (!u) return;
      m.set(u, (m.get(u)||0) + 1);
    });
    return Array.from(m.entries())
      .map(([univ, pass])=>({univ, pass}))
      .sort((a,b)=> b.pass - a.pass || a.univ.localeCompare(b.univ, "ko"));
  };

  // (A) 특목대 (어디 지역이든)
  const spRows = passRows.filter(r => SP_SET.has(normalizeUniv(r.univ)));

  // (B) 수도권: region 있으면 region으로, 없으면 “보정된 대학명”으로는 판정하지 않고 제외(원칙: region 최우선)
  const metroRows = passRows.filter(r => {
    const metro = isMetroByRegion(r.region);
    if (metro === null) return false; // region 없으면 수도권 표에서는 제외(원칙)
    return metro;
  });

  return {
    metroPassByUniv: countByUniv(metroRows),
    spUnivPassByUniv: countByUniv(spRows),
  };
}

  </script>
</body>
</html>
